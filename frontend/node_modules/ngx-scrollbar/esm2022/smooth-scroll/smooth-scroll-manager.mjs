import { Inject, Injectable, PLATFORM_ID, Optional } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { getRtlScrollAxisType, RtlScrollAxisType } from '@angular/cdk/platform';
import { Observable, Subject, animationFrameScheduler, fromEvent, merge, of, expand, finalize, take, takeUntil, takeWhile } from 'rxjs';
import BezierEasing from './bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
// @dynamic
export class SmoothScrollManager {
    get _w() {
        return this._document.defaultView;
    }
    /**
     * Timing method
     */
    get _now() {
        return this._w.performance?.now?.bind(this._w.performance) || Date.now;
    }
    constructor(_document, _platform, customDefaultOptions) {
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions, so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = {
            duration: 468,
            easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            },
            ...customDefaultOptions,
        };
    }
    /**
     * changes scroll position inside an element
     */
    _scrollElement(el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    }
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    _getElement(el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    }
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    _initSmoothScroll(el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    _isFinished(context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    _interrupted(el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    }
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    _destroy(el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    _step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            animationFrameScheduler.schedule(() => subscriber.next(context));
        });
    }
    _applyScrollToOptions(el, options) {
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        const destroyed = this._initSmoothScroll(el);
        const context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration,
            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        return new Promise(resolve => {
            // Scroll each step recursively
            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();
        });
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    scrollTo(scrollable, customOptions) {
        if (isPlatformBrowser(this._platform)) {
            const el = this._getElement(scrollable);
            const isRtl = getComputedStyle(el).direction === 'rtl';
            const rtlScrollAxisType = getRtlScrollAxisType();
            const options = {
                ...this._defaultOptions,
                ...customOptions,
                ...{
                    // Rewrite start & end offsets as right or left offsets.
                    left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                    right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
                }
            };
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                options.top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== RtlScrollAxisType.NORMAL) {
                if (options.left != null) {
                    options.right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    options.left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
        return Promise.resolve();
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(scrollable, target, customOptions = {}) {
        const scrollableEl = this._getElement(scrollable);
        const targetEl = this._getElement(target, scrollableEl);
        const options = {
            ...customOptions,
            ...{
                left: targetEl.offsetLeft + (customOptions.left || 0),
                top: targetEl.offsetTop + (customOptions.top || 0)
            }
        };
        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: SmoothScrollManager, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: SMOOTH_SCROLL_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: SmoothScrollManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SMOOTH_SCROLL_OPTIONS]
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zbW9vdGgtc2Nyb2xsL3NyYy9zbW9vdGgtc2Nyb2xsLW1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFjLE1BQU0sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RixPQUFPLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRWhGLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFjLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEosT0FBTyxZQUFZLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUNMLHFCQUFxQixFQUt0QixNQUFNLHVCQUF1QixDQUFDOztBQUUvQixXQUFXO0FBSVgsTUFBTSxPQUFPLG1CQUFtQjtJQVc5QixJQUFZLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVksSUFBSTtRQUNkLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDekUsQ0FBQztJQUVELFlBQXNDLFNBQW1CLEVBQ2hC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SSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDeEQsTUFBTSxPQUFPLEdBQTBCO1lBQ3JDLEdBQUcsYUFBYTtZQUNoQixHQUFHO2dCQUNELElBQUksRUFBRSxRQUFRLENBQUMsVUFBVSxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7Z0JBQ3JELEdBQUcsRUFBRSxRQUFRLENBQUMsU0FBUyxHQUFHLENBQUMsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7YUFDbkQ7U0FDRixDQUFDO1FBQ0YsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDN0UsQ0FBQzs4R0F4TlUsbUJBQW1CLGtCQXNCVixRQUFRLGFBQ1IsV0FBVyxhQUNDLHFCQUFxQjtrSEF4QjFDLG1CQUFtQixjQUZsQixNQUFNOzsyRkFFUCxtQkFBbUI7a0JBSC9CLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzswQkF1QmMsTUFBTTsyQkFBQyxRQUFROzswQkFDZixNQUFNOzJCQUFDLFdBQVc7OzBCQUNsQixRQUFROzswQkFBSSxNQUFNOzJCQUFDLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERPQ1VNRU5ULCBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IGNvZXJjZUVsZW1lbnQgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xyXG5pbXBvcnQgeyBnZXRSdGxTY3JvbGxBeGlzVHlwZSwgUnRsU2Nyb2xsQXhpc1R5cGUgfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xyXG5pbXBvcnQgeyBfQm90dG9tLCBfTGVmdCwgX1JpZ2h0LCBfVG9wLCBfV2l0aG91dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zY3JvbGxpbmcnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpYmVyLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciwgZnJvbUV2ZW50LCBtZXJnZSwgb2YsIGV4cGFuZCwgZmluYWxpemUsIHRha2UsIHRha2VVbnRpbCwgdGFrZVdoaWxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCBCZXppZXJFYXNpbmcgZnJvbSAnLi9iZXppZXItZWFzaW5nJztcclxuaW1wb3J0IHtcclxuICBTTU9PVEhfU0NST0xMX09QVElPTlMsXHJcbiAgU21vb3RoU2Nyb2xsRWxlbWVudCxcclxuICBTbW9vdGhTY3JvbGxTdGVwLFxyXG4gIFNtb290aFNjcm9sbFRvRWxlbWVudE9wdGlvbnMsXHJcbiAgU21vb3RoU2Nyb2xsVG9PcHRpb25zXHJcbn0gZnJvbSAnLi9zbW9vdGgtc2Nyb2xsLm1vZGVsJztcclxuXHJcbi8vIEBkeW5hbWljXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIFNtb290aFNjcm9sbE1hbmFnZXIge1xyXG5cclxuICAvLyBEZWZhdWx0IG9wdGlvbnNcclxuICBwcml2YXRlIHJlYWRvbmx5IF9kZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zO1xyXG5cclxuICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgb25nb2luZyBTbW9vdGhTY3JvbGwgZnVuY3Rpb25zLCBzbyB0aGV5IGNhbiBiZSBoYW5kbGVkIGluIGNhc2Ugb2YgZHVwbGljYXRpb24uXHJcbiAgLy8gRWFjaCBzY3JvbGxlZCBlbGVtZW50IGdldHMgYSBkZXN0cm95ZXIgc3RyZWFtIHdoaWNoIGdldHMgZGVsZXRlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBjb21wbGV0ZXMuXHJcbiAgLy8gUHVycG9zZTogSWYgdXNlciBjYWxsZWQgYSBzY3JvbGwgZnVuY3Rpb24gYWdhaW4gb24gdGhlIHNhbWUgZWxlbWVudCBiZWZvcmUgdGhlIHNjcm9sbHMgY29tcGxldGVzLFxyXG4gIC8vIGl0IGNhbmNlbHMgdGhlIG9uZ29pbmcgc2Nyb2xsIGFuZCBzdGFydHMgYSBuZXcgb25lXHJcbiAgcHJpdmF0ZSBfb25Hb2luZ1Njcm9sbHM6IE1hcDxIVE1MRWxlbWVudCwgU3ViamVjdDx2b2lkPj4gPSBuZXcgTWFwPEhUTUxFbGVtZW50LCBTdWJqZWN0PHZvaWQ+PigpO1xyXG5cclxuICBwcml2YXRlIGdldCBfdygpOiBXaW5kb3cge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGltaW5nIG1ldGhvZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0IF9ub3coKTogKCkgPT4gbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl93LnBlcmZvcm1hbmNlPy5ub3c/LmJpbmQodGhpcy5fdy5wZXJmb3JtYW5jZSkgfHwgRGF0ZS5ub3c7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogRG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBfcGxhdGZvcm06IG9iamVjdCxcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFNNT09USF9TQ1JPTExfT1BUSU9OUykgY3VzdG9tRGVmYXVsdE9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucykge1xyXG4gICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgIGR1cmF0aW9uOiA0NjgsXHJcbiAgICAgIGVhc2luZzoge1xyXG4gICAgICAgIHgxOiAwLjQyLFxyXG4gICAgICAgIHkxOiAwLFxyXG4gICAgICAgIHgyOiAwLjU4LFxyXG4gICAgICAgIHkyOiAxXHJcbiAgICAgIH0sXHJcbiAgICAgIC4uLmN1c3RvbURlZmF1bHRPcHRpb25zLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc2Nyb2xsRWxlbWVudChlbDogSFRNTEVsZW1lbnQsIHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBlbC5zY3JvbGxMZWZ0ID0geDtcclxuICAgIGVsLnNjcm9sbFRvcCA9IHk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGEgZ2l2ZW4gcGFyYW1ldGVyIG9mIHR5cGUgSFRNTEVsZW1lbnQsIEVsZW1lbnRSZWYgb3Igc2VsZWN0b3JcclxuICAgKi9cclxuICBwcml2YXRlIF9nZXRFbGVtZW50KGVsOiBIVE1MRWxlbWVudCB8IEVsZW1lbnRSZWYgfCBzdHJpbmcsIHBhcmVudD86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xyXG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIChwYXJlbnQgfHwgdGhpcy5fZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3IoZWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvZXJjZUVsZW1lbnQ8SFRNTEVsZW1lbnQ+KGVsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIGEgZGVzdHJveWVyIHN0cmVhbSwgcmUtaW5pdGlhbGl6ZXMgaXQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBzY3JvbGxlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2luaXRTbW9vdGhTY3JvbGwoZWw6IEhUTUxFbGVtZW50KTogU3ViamVjdDx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5fb25Hb2luZ1Njcm9sbHMuaGFzKGVsKSkge1xyXG4gICAgICB0aGlzLl9vbkdvaW5nU2Nyb2xscy5nZXQoZWwpIS5uZXh0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fb25Hb2luZ1Njcm9sbHMuc2V0KGVsLCBuZXcgU3ViamVjdDx2b2lkPigpKSEuZ2V0KGVsKSE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgc21vb3RoIHNjcm9sbCBoYXMgcmVhY2hlZCwgY2xlYW5zIHVwIHRoZSBzbW9vdGggc2Nyb2xsIHN0cmVhbSBhbmQgcmVzb2x2ZXMgaXRzIHByb21pc2VcclxuICAgKi9cclxuICBwcml2YXRlIF9pc0ZpbmlzaGVkKGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXAsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPiwgcmVzb2x2ZTogKCkgPT4gdm9pZCk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGNvbnRleHQuY3VycmVudFggIT09IGNvbnRleHQueCB8fCBjb250ZXh0LmN1cnJlbnRZICE9PSBjb250ZXh0LnkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95ZWQubmV4dCgpO1xyXG4gICAgcmVzb2x2ZSgpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVybWluYXRlcyBhbiBvbmdvaW5nIHNtb290aCBzY3JvbGxcclxuICAgKi9cclxuICBwcml2YXRlIF9pbnRlcnJ1cHRlZChlbDogSFRNTEVsZW1lbnQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IE9ic2VydmFibGU8RXZlbnQgfCB2b2lkPiB7XHJcbiAgICByZXR1cm4gbWVyZ2UoXHJcbiAgICAgIGZyb21FdmVudChlbCwgJ3doZWVsJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxyXG4gICAgICBmcm9tRXZlbnQoZWwsICd0b3VjaG1vdmUnLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSksXHJcbiAgICAgIGRlc3Ryb3llZFxyXG4gICAgKS5waXBlKHRha2UoMSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlcyB0aGUgZGVzdHJveWVyIGZ1bmN0aW9uLCBydW5zIGlmIHRoZSBzbW9vdGggc2Nyb2xsIGhhcyBmaW5pc2hlZCBvciBpbnRlcnJ1cHRlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2Rlc3Ryb3koZWw6IEhUTUxFbGVtZW50LCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiB2b2lkIHtcclxuICAgIGRlc3Ryb3llZC5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fb25Hb2luZ1Njcm9sbHMuZGVsZXRlKGVsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgZnVuY3Rpb24gY2FsbGVkIHJlY3Vyc2l2ZWx5IHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcclxuICAgKi9cclxuICBwcml2YXRlIF9zdGVwKGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXApOiBPYnNlcnZhYmxlPFNtb290aFNjcm9sbFN0ZXA+IHtcclxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxTbW9vdGhTY3JvbGxTdGVwPikgPT4ge1xyXG4gICAgICBsZXQgZWxhcHNlZCA9ICh0aGlzLl9ub3coKSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIGNvbnRleHQuZHVyYXRpb247XHJcblxyXG4gICAgICAvLyBhdm9pZCBlbGFwc2VkIHRpbWVzIGhpZ2hlciB0aGFuIG9uZVxyXG4gICAgICBlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcclxuXHJcbiAgICAgIC8vIGFwcGx5IGVhc2luZyB0byBlbGFwc2VkIHRpbWVcclxuICAgICAgY29uc3QgdmFsdWU6IG51bWJlciA9IGNvbnRleHQuZWFzaW5nKGVsYXBzZWQpO1xyXG5cclxuICAgICAgY29udGV4dC5jdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQueCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xyXG4gICAgICBjb250ZXh0LmN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XHJcblxyXG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50KGNvbnRleHQuc2Nyb2xsYWJsZSwgY29udGV4dC5jdXJyZW50WCwgY29udGV4dC5jdXJyZW50WSk7XHJcbiAgICAgIC8vIFByb2NlZWQgdG8gdGhlIHN0ZXBcclxuICAgICAgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIuc2NoZWR1bGUoKCkgPT4gc3Vic2NyaWJlci5uZXh0KGNvbnRleHQpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfYXBwbHlTY3JvbGxUb09wdGlvbnMoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghb3B0aW9ucy5kdXJhdGlvbiEpIHtcclxuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudChlbCwgb3B0aW9ucyEubGVmdCEsIG9wdGlvbnMhLnRvcCEpO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBhIGRlc3Ryb3llciBzdHJlYW0sIHJlaW5pdGlhbGl6ZSBpdCBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIHNjcm9sbGVkXHJcbiAgICBjb25zdCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4gPSB0aGlzLl9pbml0U21vb3RoU2Nyb2xsKGVsKTtcclxuXHJcbiAgICBjb25zdCBjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwID0ge1xyXG4gICAgICBzY3JvbGxhYmxlOiBlbCxcclxuICAgICAgc3RhcnRUaW1lOiB0aGlzLl9ub3coKSxcclxuICAgICAgc3RhcnRYOiBlbC5zY3JvbGxMZWZ0LFxyXG4gICAgICBzdGFydFk6IGVsLnNjcm9sbFRvcCxcclxuICAgICAgeDogb3B0aW9ucy5sZWZ0ID09IG51bGwgPyBlbC5zY3JvbGxMZWZ0IDogfn5vcHRpb25zLmxlZnQsXHJcbiAgICAgIHk6IG9wdGlvbnMudG9wID09IG51bGwgPyBlbC5zY3JvbGxUb3AgOiB+fm9wdGlvbnMudG9wLFxyXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbiEsXHJcbiAgICAgIGVhc2luZzogQmV6aWVyRWFzaW5nKG9wdGlvbnMuZWFzaW5nIS54MSEsIG9wdGlvbnMuZWFzaW5nIS55MSEsIG9wdGlvbnMuZWFzaW5nIS54MiEsIG9wdGlvbnMuZWFzaW5nIS55MiEpXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgLy8gU2Nyb2xsIGVhY2ggc3RlcCByZWN1cnNpdmVseVxyXG4gICAgICBvZihudWxsKS5waXBlKFxyXG4gICAgICAgIGV4cGFuZCgoKSA9PiB0aGlzLl9zdGVwKGNvbnRleHQpLnBpcGUoXHJcbiAgICAgICAgICB0YWtlV2hpbGUoKGN1cnJDb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKSA9PiB0aGlzLl9pc0ZpbmlzaGVkKGN1cnJDb250ZXh0LCBkZXN0cm95ZWQsIHJlc29sdmUpKVxyXG4gICAgICAgICkpLFxyXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9pbnRlcnJ1cHRlZChlbCwgZGVzdHJveWVkKSksXHJcbiAgICAgICAgZmluYWxpemUoKCkgPT4gdGhpcy5fZGVzdHJveShlbCwgZGVzdHJveWVkKSlcclxuICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBvZmZzZXRzLiBUaGlzIGlzIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNjcm9sbFRvXHJcbiAgICogbWV0aG9kLCBzaW5jZSBicm93c2VycyBhcmUgbm90IGNvbnNpc3RlbnQgYWJvdXQgd2hhdCBzY3JvbGxMZWZ0IG1lYW5zIGluIFJUTC4gRm9yIHRoaXMgbWV0aG9kXHJcbiAgICogbGVmdCBhbmQgcmlnaHQgYWx3YXlzIHJlZmVyIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyIGlycmVzcGVjdGl2ZVxyXG4gICAqIG9mIHRoZSBsYXlvdXQgZGlyZWN0aW9uLiBzdGFydCBhbmQgZW5kIHJlZmVyIHRvIGxlZnQgYW5kIHJpZ2h0IGluIGFuIExUUiBjb250ZXh0IGFuZCB2aWNlLXZlcnNhXHJcbiAgICogaW4gYW4gUlRMIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHNjcm9sbGFibGUgZWxlbWVudFxyXG4gICAqIEBwYXJhbSBjdXN0b21PcHRpb25zIHNwZWNpZmllZCB0aGUgb2Zmc2V0cyB0byBzY3JvbGwgdG8uXHJcbiAgICovXHJcbiAgc2Nyb2xsVG8oc2Nyb2xsYWJsZTogU21vb3RoU2Nyb2xsRWxlbWVudCwgY3VzdG9tT3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm0pKSB7XHJcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcclxuICAgICAgY29uc3QgaXNSdGwgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5kaXJlY3Rpb24gPT09ICdydGwnO1xyXG4gICAgICBjb25zdCBydGxTY3JvbGxBeGlzVHlwZSA9IGdldFJ0bFNjcm9sbEF4aXNUeXBlKCk7XHJcblxyXG4gICAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XHJcbiAgICAgICAgLi4uKHRoaXMuX2RlZmF1bHRPcHRpb25zIGFzIF9XaXRob3V0PF9Cb3R0b20gJiBfVG9wPiksXHJcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcclxuICAgICAgICAuLi4oe1xyXG4gICAgICAgICAgLy8gUmV3cml0ZSBzdGFydCAmIGVuZCBvZmZzZXRzIGFzIHJpZ2h0IG9yIGxlZnQgb2Zmc2V0cy5cclxuICAgICAgICAgIGxlZnQ6IGN1c3RvbU9wdGlvbnMubGVmdCA9PSBudWxsID8gKGlzUnRsID8gY3VzdG9tT3B0aW9ucy5lbmQgOiBjdXN0b21PcHRpb25zLnN0YXJ0KSA6IGN1c3RvbU9wdGlvbnMubGVmdCxcclxuICAgICAgICAgIHJpZ2h0OiBjdXN0b21PcHRpb25zLnJpZ2h0ID09IG51bGwgPyAoaXNSdGwgPyBjdXN0b21PcHRpb25zLnN0YXJ0IDogY3VzdG9tT3B0aW9ucy5lbmQpIDogY3VzdG9tT3B0aW9ucy5yaWdodFxyXG4gICAgICAgIH0gYXMgX1dpdGhvdXQ8X0JvdHRvbSAmIF9Ub3A+KVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gUmV3cml0ZSB0aGUgYm90dG9tIG9mZnNldCBhcyBhIHRvcCBvZmZzZXQuXHJcbiAgICAgIGlmIChvcHRpb25zLmJvdHRvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X0JvdHRvbT4gJiBfVG9wKS50b3AgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQgLSBvcHRpb25zLmJvdHRvbTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmV3cml0ZSB0aGUgcmlnaHQgb2Zmc2V0IGFzIGEgbGVmdCBvZmZzZXQuXHJcbiAgICAgIGlmIChpc1J0bCAmJiBydGxTY3JvbGxBeGlzVHlwZSAhPT0gUnRsU2Nyb2xsQXhpc1R5cGUuTk9STUFMKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfTGVmdD4gJiBfUmlnaHQpLnJpZ2h0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIG9wdGlvbnMubGVmdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcclxuICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCkge1xyXG4gICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodCA/IC1vcHRpb25zLnJpZ2h0IDogb3B0aW9ucy5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X1JpZ2h0PiAmIF9MZWZ0KS5sZWZ0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIG9wdGlvbnMucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNjcm9sbFRvT3B0aW9ucyhlbCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgdG8gZWxlbWVudCBieSByZWZlcmVuY2Ugb3Igc2VsZWN0b3JcclxuICAgKi9cclxuICBzY3JvbGxUb0VsZW1lbnQoc2Nyb2xsYWJsZTogU21vb3RoU2Nyb2xsRWxlbWVudCwgdGFyZ2V0OiBTbW9vdGhTY3JvbGxFbGVtZW50LCBjdXN0b21PcHRpb25zOiBTbW9vdGhTY3JvbGxUb0VsZW1lbnRPcHRpb25zID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IHNjcm9sbGFibGVFbCA9IHRoaXMuX2dldEVsZW1lbnQoc2Nyb2xsYWJsZSk7XHJcbiAgICBjb25zdCB0YXJnZXRFbCA9IHRoaXMuX2dldEVsZW1lbnQodGFyZ2V0LCBzY3JvbGxhYmxlRWwpO1xyXG4gICAgY29uc3Qgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zID0ge1xyXG4gICAgICAuLi5jdXN0b21PcHRpb25zLFxyXG4gICAgICAuLi57XHJcbiAgICAgICAgbGVmdDogdGFyZ2V0RWwub2Zmc2V0TGVmdCArIChjdXN0b21PcHRpb25zLmxlZnQgfHwgMCksXHJcbiAgICAgICAgdG9wOiB0YXJnZXRFbC5vZmZzZXRUb3AgKyAoY3VzdG9tT3B0aW9ucy50b3AgfHwgMClcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiB0YXJnZXRFbCA/IHRoaXMuc2Nyb2xsVG8oc2Nyb2xsYWJsZUVsLCBvcHRpb25zKSA6IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH1cclxufVxyXG4iXX0=