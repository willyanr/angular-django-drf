import { ContentChild, Directive, inject, effect, ElementRef } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { BehaviorSubject, merge, fromEvent, tap, map, expand, delay, switchMap, finalize, takeWhile, takeUntil, distinctUntilChanged, EMPTY } from 'rxjs';
import { NG_SCROLLBAR } from '../utils/scrollbar-base';
import { enableSelection, preventSelection, stopPropagation } from '../utils/common';
import { ThumbAdapter } from '../thumb/thumb-adapter';
import { resizeSensor } from '../viewport';
import * as i0 from "@angular/core";
// @dynamic
export class TrackAdapter {
    get dragged() {
        const mouseDown$ = fromEvent(this.nativeElement, 'pointerdown').pipe(stopPropagation(), preventSelection(this.document));
        const mouseUp$ = fromEvent(this.document, 'pointerup', { passive: true }).pipe(enableSelection(this.document));
        // The reason why we use mousemove instead of mouseover, that we need to save the current mouse location
        const mouseMove$ = fromEvent(this.nativeElement, 'pointermove', { passive: true }).pipe(map((e) => {
            this.currMousePosition = e[this.clientProperty];
            return true;
        }));
        const mouseOut$ = fromEvent(this.nativeElement, 'pointerout', { passive: true }).pipe(map(() => {
            return false;
        }));
        // Stream that combines mousemove and mouseover and only emit when mouse gets in or out the track
        // NOTE: we must use a BehaviorSubject to get the value asap the onTrackFirstClick function is called
        const mouseOverTrack$ = new BehaviorSubject(true);
        return mouseDown$.pipe(switchMap((startEvent) => {
            // We need to subscribe to mousemove and mouseout events before calling the onTrackFirstClick
            // Because we need to tell if mouse is over or not asap the first function is done
            // Otherwise, if user click first time and moved the mouse away immediately, the mouseout will not be detected
            merge(mouseMove$, mouseOut$).pipe(distinctUntilChanged(), tap((over) => mouseOverTrack$.next(over)), takeUntil(mouseUp$)).subscribe();
            // TODO: Verify if this is needed
            // This should stop propagating the move event when pointer is moving over the thumb
            fromEvent(this.thumb.nativeElement, 'pointermove').pipe(stopPropagation(), takeUntil(mouseUp$)).subscribe();
            return this.onTrackFirstClick(startEvent).pipe(switchMap((final) => {
                // If scroll has reached the destination from the first scroll call, end the stream
                if (final) {
                    return EMPTY;
                }
                // Otherwise, activate mousemove and mouseout events and switch to ongoing scroll calls
                return mouseOverTrack$.pipe(switchMap((over) => {
                    const currDirection = this.getScrollDirection();
                    const sameDirection = this.scrollDirection === currDirection;
                    // If mouse is out the track pause the scroll calls, otherwise keep going
                    return (over && sameDirection) ? this.onTrackOngoingMousedown() : EMPTY;
                }), finalize(() => {
                    // Reset the mouseOverTrack$ state
                    mouseOverTrack$.next(true);
                }));
            }), takeUntil(mouseUp$));
        }));
    }
    // Get track client rect
    get clientRect() {
        return this.nativeElement.getBoundingClientRect();
    }
    getScrollDirection() {
        return this.currMousePosition - this.thumb.offset > 0 ? 'forward' : 'backward';
    }
    constructor() {
        this.nativeElement = inject((ElementRef)).nativeElement;
        this.cmp = inject(NG_SCROLLBAR);
        this.document = inject(DOCUMENT);
        effect((onCleanup) => {
            if (this.cmp.disableSensor()) {
                this.updateCSSVariables();
                this.sizeChangeSub?.unsubscribe();
            }
            else {
                this.sizeChangeSub = resizeSensor(this.nativeElement, this.cmp.sensorThrottleTime(), true).pipe(tap(() => this.updateCSSVariables())).subscribe();
            }
            onCleanup(() => this.sizeChangeSub?.unsubscribe());
        });
    }
    updateCSSVariables() {
        this.cmp.nativeElement.style.setProperty(this.cssLengthProperty, `${this.size}`);
    }
    /**
     * Scrolls to position when mouse is down the on the track the first time
     */
    onTrackFirstClick(e) {
        this.currMousePosition = e[this.clientProperty];
        // Save scroll direction
        this.scrollDirection = this.getScrollDirection();
        let value;
        let final;
        // Check which direction should the scroll go (up or down)
        if (this.scrollDirection === 'forward') {
            // Scroll down
            const scrollDownIncrement = this.viewportScrollOffset + this.viewportViewportSize;
            // Check if the incremental position is bigger than the scroll max
            const scrollMax = this.viewportScrollSize - this.viewportViewportSize;
            if (scrollDownIncrement >= scrollMax) {
                value = scrollMax;
                final = true;
            }
            else {
                value = scrollDownIncrement;
            }
        }
        else {
            // Scroll up
            const scrollUpIncrement = this.viewportScrollOffset - this.viewportViewportSize;
            if (scrollUpIncrement <= 0) {
                value = 0;
                final = true;
            }
            else {
                value = scrollUpIncrement;
            }
        }
        return this.scrollTo(value).pipe(delay(200), map(() => final));
    }
    /**
     * Callback that is called when mouse is still down on the track
     */
    onTrackOngoingMousedown() {
        const scrollFinal = this.getRelativePosition();
        let value;
        let final;
        // Check which direction should the scroll go (up or down)
        if (this.scrollDirection === 'forward') {
            // Scroll down
            const scrollDownIncrement = this.viewportScrollOffset + this.viewportViewportSize;
            // Check if the incremental position is bigger than the scroll max
            if (scrollDownIncrement >= scrollFinal) {
                value = scrollFinal;
                final = true;
            }
            else {
                value = scrollDownIncrement;
            }
        }
        else {
            // Scroll up
            const scrollUpIncrement = this.viewportScrollOffset - this.viewportViewportSize;
            if (scrollUpIncrement <= scrollFinal) {
                value = scrollFinal;
                final = true;
            }
            else {
                value = scrollUpIncrement;
            }
        }
        return this.scrollTo(value).pipe(takeWhile(() => !final), expand(() => this.onTrackOngoingMousedown()));
    }
    getRelativePosition() {
        const clickPosition = this.currMousePosition - this.offset;
        const current = clickPosition / this.size;
        return current * (this.viewportScrollSize - this.viewportViewportSize);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: TrackAdapter, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.1", type: TrackAdapter, queries: [{ propertyName: "thumb", first: true, predicate: ThumbAdapter, descendants: true }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: TrackAdapter, decorators: [{
            type: Directive
        }], ctorParameters: () => [], propDecorators: { thumb: [{
                type: ContentChild,
                args: [ThumbAdapter]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2stYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1zY3JvbGxiYXIvc3JjL2xpYi90cmFjay90cmFjay1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUEyQixNQUFNLGVBQWUsQ0FBQztBQUM3RyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUVMLGVBQWUsRUFDZixLQUFLLEVBQ0wsU0FBUyxFQUNULEdBQUcsRUFDSCxHQUFHLEVBQ0gsTUFBTSxFQUNOLEtBQUssRUFDTCxTQUFTLEVBQ1QsUUFBUSxFQUNSLFNBQVMsRUFDVCxTQUFTLEVBQ1Qsb0JBQW9CLEVBQ3BCLEtBQUssRUFDTixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxZQUFZLEVBQWdCLE1BQU0seUJBQXlCLENBQUM7QUFDckUsT0FBTyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNyRixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDdEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGFBQWEsQ0FBQzs7QUFHM0MsV0FBVztBQUVYLE1BQU0sT0FBZ0IsWUFBWTtJQXFCaEMsSUFBSSxPQUFPO1FBQ1QsTUFBTSxVQUFVLEdBQTZCLFNBQVMsQ0FBZSxJQUFJLENBQUMsYUFBYSxFQUFFLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FDMUcsZUFBZSxFQUFFLEVBQ2pCLGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FDaEMsQ0FBQztRQUNGLE1BQU0sUUFBUSxHQUE2QixTQUFTLENBQWUsSUFBSSxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQ3BILGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQy9CLENBQUM7UUFFRix3R0FBd0c7UUFDeEcsTUFBTSxVQUFVLEdBQXdCLFNBQVMsQ0FBZSxJQUFJLENBQUMsYUFBYSxFQUFFLGFBQWEsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDeEgsR0FBRyxDQUFDLENBQUMsQ0FBZSxFQUFFLEVBQUU7WUFDdEIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDaEQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FDSCxDQUFDO1FBRUYsTUFBTSxTQUFTLEdBQXdCLFNBQVMsQ0FBZSxJQUFJLENBQUMsYUFBYSxFQUFFLFlBQVksRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDdEgsR0FBRyxDQUFDLEdBQUcsRUFBRTtZQUNQLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUVGLGlHQUFpRztRQUNqRyxxR0FBcUc7UUFDckcsTUFBTSxlQUFlLEdBQTZCLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTVFLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FDcEIsU0FBUyxDQUFDLENBQUMsVUFBd0IsRUFBRSxFQUFFO1lBQ3JDLDZGQUE2RjtZQUM3RixrRkFBa0Y7WUFDbEYsOEdBQThHO1lBQzlHLEtBQUssQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUMvQixvQkFBb0IsRUFBRSxFQUN0QixHQUFHLENBQUMsQ0FBQyxJQUFhLEVBQUUsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFDbEQsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUNwQixDQUFDLFNBQVMsRUFBRSxDQUFDO1lBRWQsaUNBQWlDO1lBQ2pDLG9GQUFvRjtZQUNwRixTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUNyRCxlQUFlLEVBQUUsRUFDakIsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUNwQixDQUFDLFNBQVMsRUFBRSxDQUFDO1lBRWQsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUM1QyxTQUFTLENBQUMsQ0FBQyxLQUFjLEVBQUUsRUFBRTtnQkFDM0IsbUZBQW1GO2dCQUNuRixJQUFJLEtBQUssRUFBRTtvQkFDVCxPQUFPLEtBQUssQ0FBQztpQkFDZDtnQkFDRCx1RkFBdUY7Z0JBQ3ZGLE9BQU8sZUFBZSxDQUFDLElBQUksQ0FDekIsU0FBUyxDQUFDLENBQUMsSUFBYSxFQUFFLEVBQUU7b0JBQzFCLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO29CQUNoRCxNQUFNLGFBQWEsR0FBWSxJQUFJLENBQUMsZUFBZSxLQUFLLGFBQWEsQ0FBQztvQkFDdEUseUVBQXlFO29CQUN6RSxPQUFPLENBQUMsSUFBSSxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO2dCQUMxRSxDQUFDLENBQUMsRUFDRixRQUFRLENBQUMsR0FBRyxFQUFFO29CQUNaLGtDQUFrQztvQkFDbEMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDN0IsQ0FBQyxDQUFDLENBQ0gsQ0FBQztZQUNKLENBQUMsQ0FBQyxFQUNGLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FDcEIsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBWUQsd0JBQXdCO0lBQ3hCLElBQUksVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ3BELENBQUM7SUFFTyxrQkFBa0I7UUFDeEIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUNqRixDQUFDO0lBRUQ7UUE3R1Msa0JBQWEsR0FBZ0IsTUFBTSxDQUFDLENBQUEsVUFBdUIsQ0FBQSxDQUFDLENBQUMsYUFBYSxDQUFDO1FBQ2pFLFFBQUcsR0FBaUIsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3pDLGFBQVEsR0FBYSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUE0R3ZELE1BQU0sQ0FBQyxDQUFDLFNBQWtDLEVBQUUsRUFBRTtZQUM1QyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLEVBQUU7Z0JBQzVCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO2dCQUMxQixJQUFJLENBQUMsYUFBYSxFQUFFLFdBQVcsRUFBRSxDQUFDO2FBQ25DO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxhQUFhLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksQ0FDN0YsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLENBQ3JDLENBQUMsU0FBUyxFQUFFLENBQUM7YUFDZjtZQUVELFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUM7UUFDckQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sa0JBQWtCO1FBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEdBQUksSUFBSSxDQUFDLElBQUssRUFBRSxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUVEOztPQUVHO0lBQ0gsaUJBQWlCLENBQUMsQ0FBZTtRQUMvQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNoRCx3QkFBd0I7UUFDeEIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUVqRCxJQUFJLEtBQWEsQ0FBQztRQUNsQixJQUFJLEtBQWMsQ0FBQztRQUVuQiwwREFBMEQ7UUFDMUQsSUFBSSxJQUFJLENBQUMsZUFBZSxLQUFLLFNBQVMsRUFBRTtZQUN0QyxjQUFjO1lBQ2QsTUFBTSxtQkFBbUIsR0FBVyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1lBQzFGLGtFQUFrRTtZQUNsRSxNQUFNLFNBQVMsR0FBVyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1lBQzlFLElBQUksbUJBQW1CLElBQUksU0FBUyxFQUFFO2dCQUNwQyxLQUFLLEdBQUcsU0FBUyxDQUFDO2dCQUNsQixLQUFLLEdBQUcsSUFBSSxDQUFDO2FBQ2Q7aUJBQU07Z0JBQ0wsS0FBSyxHQUFHLG1CQUFtQixDQUFDO2FBQzdCO1NBQ0Y7YUFBTTtZQUNMLFlBQVk7WUFDWixNQUFNLGlCQUFpQixHQUFXLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUM7WUFDeEYsSUFBSSxpQkFBaUIsSUFBSSxDQUFDLEVBQUU7Z0JBQzFCLEtBQUssR0FBRyxDQUFDLENBQUM7Z0JBQ1YsS0FBSyxHQUFHLElBQUksQ0FBQzthQUNkO2lCQUFNO2dCQUNMLEtBQUssR0FBRyxpQkFBaUIsQ0FBQzthQUMzQjtTQUNGO1FBRUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FDOUIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUNWLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FDakIsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNILHVCQUF1QjtRQUNyQixNQUFNLFdBQVcsR0FBVyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUV2RCxJQUFJLEtBQWEsQ0FBQztRQUNsQixJQUFJLEtBQWMsQ0FBQztRQUVuQiwwREFBMEQ7UUFDMUQsSUFBSSxJQUFJLENBQUMsZUFBZSxLQUFLLFNBQVMsRUFBRTtZQUN0QyxjQUFjO1lBQ2QsTUFBTSxtQkFBbUIsR0FBVyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1lBQzFGLGtFQUFrRTtZQUNsRSxJQUFJLG1CQUFtQixJQUFJLFdBQVcsRUFBRTtnQkFDdEMsS0FBSyxHQUFHLFdBQVcsQ0FBQztnQkFDcEIsS0FBSyxHQUFHLElBQUksQ0FBQzthQUNkO2lCQUFNO2dCQUNMLEtBQUssR0FBRyxtQkFBbUIsQ0FBQzthQUM3QjtTQUNGO2FBQU07WUFDTCxZQUFZO1lBQ1osTUFBTSxpQkFBaUIsR0FBVyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1lBQ3hGLElBQUksaUJBQWlCLElBQUksV0FBVyxFQUFFO2dCQUNwQyxLQUFLLEdBQUcsV0FBVyxDQUFDO2dCQUNwQixLQUFLLEdBQUcsSUFBSSxDQUFDO2FBQ2Q7aUJBQU07Z0JBQ0wsS0FBSyxHQUFHLGlCQUFpQixDQUFDO2FBQzNCO1NBQ0Y7UUFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUM5QixTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFDdkIsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLENBQzdDLENBQUM7SUFDSixDQUFDO0lBRU8sbUJBQW1CO1FBQ3pCLE1BQU0sYUFBYSxHQUFXLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ25FLE1BQU0sT0FBTyxHQUFXLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ2xELE9BQU8sT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7OEdBbk5tQixZQUFZO2tHQUFaLFlBQVksNkRBbUJsQixZQUFZOzsyRkFuQk4sWUFBWTtrQkFEakMsU0FBUzt3REFvQjRCLEtBQUs7c0JBQXhDLFlBQVk7dUJBQUMsWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRlbnRDaGlsZCwgRGlyZWN0aXZlLCBpbmplY3QsIGVmZmVjdCwgRWxlbWVudFJlZiwgRWZmZWN0Q2xlYW51cFJlZ2lzdGVyRm4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQge1xyXG4gIE9ic2VydmFibGUsXHJcbiAgQmVoYXZpb3JTdWJqZWN0LFxyXG4gIG1lcmdlLFxyXG4gIGZyb21FdmVudCxcclxuICB0YXAsXHJcbiAgbWFwLFxyXG4gIGV4cGFuZCxcclxuICBkZWxheSxcclxuICBzd2l0Y2hNYXAsXHJcbiAgZmluYWxpemUsXHJcbiAgdGFrZVdoaWxlLFxyXG4gIHRha2VVbnRpbCxcclxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcclxuICBFTVBUWSwgU3Vic2NyaXB0aW9uXHJcbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE5HX1NDUk9MTEJBUiwgX05nU2Nyb2xsYmFyIH0gZnJvbSAnLi4vdXRpbHMvc2Nyb2xsYmFyLWJhc2UnO1xyXG5pbXBvcnQgeyBlbmFibGVTZWxlY3Rpb24sIHByZXZlbnRTZWxlY3Rpb24sIHN0b3BQcm9wYWdhdGlvbiB9IGZyb20gJy4uL3V0aWxzL2NvbW1vbic7XHJcbmltcG9ydCB7IFRodW1iQWRhcHRlciB9IGZyb20gJy4uL3RodW1iL3RodW1iLWFkYXB0ZXInO1xyXG5pbXBvcnQgeyByZXNpemVTZW5zb3IgfSBmcm9tICcuLi92aWV3cG9ydCc7XHJcblxyXG5cclxuLy8gQGR5bmFtaWNcclxuQERpcmVjdGl2ZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUcmFja0FkYXB0ZXIge1xyXG5cclxuICByZWFkb25seSBuYXRpdmVFbGVtZW50OiBIVE1MRWxlbWVudCA9IGluamVjdChFbGVtZW50UmVmPEhUTUxFbGVtZW50PikubmF0aXZlRWxlbWVudDtcclxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgY21wOiBfTmdTY3JvbGxiYXIgPSBpbmplY3QoTkdfU0NST0xMQkFSKTtcclxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50ID0gaW5qZWN0KERPQ1VNRU5UKTtcclxuXHJcbiAgLyoqIFJlc2l6ZSBvYnNlcnZlciBzdWJzY3JpcHRpb24gKi9cclxuICBwcml2YXRlIHNpemVDaGFuZ2VTdWI6IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCB2aWV3cG9ydFNjcm9sbFNpemUoKTogbnVtYmVyO1xyXG5cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0IHZpZXdwb3J0Vmlld3BvcnRTaXplKCk6IG51bWJlcjtcclxuXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCB2aWV3cG9ydFNjcm9sbE9mZnNldCgpOiBudW1iZXI7XHJcblxyXG4gIC8vIFRoZSBhY3RpdmUgbW91c2UgZXZlbnQgZm9yIHRoZSBvbmdvaW5nIHRyYWNrIGRyYWdnaW5nXHJcbiAgcHJpdmF0ZSBjdXJyTW91c2VQb3NpdGlvbjogbnVtYmVyO1xyXG4gIHByaXZhdGUgc2Nyb2xsRGlyZWN0aW9uOiAnZm9yd2FyZCcgfCAnYmFja3dhcmQnO1xyXG5cclxuICBAQ29udGVudENoaWxkKFRodW1iQWRhcHRlcikgcHJpdmF0ZSB0aHVtYjogVGh1bWJBZGFwdGVyO1xyXG5cclxuICBnZXQgZHJhZ2dlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3QgbW91c2VEb3duJDogT2JzZXJ2YWJsZTxQb2ludGVyRXZlbnQ+ID0gZnJvbUV2ZW50PFBvaW50ZXJFdmVudD4odGhpcy5uYXRpdmVFbGVtZW50LCAncG9pbnRlcmRvd24nKS5waXBlKFxyXG4gICAgICBzdG9wUHJvcGFnYXRpb24oKSxcclxuICAgICAgcHJldmVudFNlbGVjdGlvbih0aGlzLmRvY3VtZW50KVxyXG4gICAgKTtcclxuICAgIGNvbnN0IG1vdXNlVXAkOiBPYnNlcnZhYmxlPFBvaW50ZXJFdmVudD4gPSBmcm9tRXZlbnQ8UG9pbnRlckV2ZW50Pih0aGlzLmRvY3VtZW50LCAncG9pbnRlcnVwJywgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUoXHJcbiAgICAgIGVuYWJsZVNlbGVjdGlvbih0aGlzLmRvY3VtZW50KVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBUaGUgcmVhc29uIHdoeSB3ZSB1c2UgbW91c2Vtb3ZlIGluc3RlYWQgb2YgbW91c2VvdmVyLCB0aGF0IHdlIG5lZWQgdG8gc2F2ZSB0aGUgY3VycmVudCBtb3VzZSBsb2NhdGlvblxyXG4gICAgY29uc3QgbW91c2VNb3ZlJDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IGZyb21FdmVudDxQb2ludGVyRXZlbnQ+KHRoaXMubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJtb3ZlJywgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUoXHJcbiAgICAgIG1hcCgoZTogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyTW91c2VQb3NpdGlvbiA9IGVbdGhpcy5jbGllbnRQcm9wZXJ0eV07XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IG1vdXNlT3V0JDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IGZyb21FdmVudDxQb2ludGVyRXZlbnQ+KHRoaXMubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJvdXQnLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShcclxuICAgICAgbWFwKCgpID0+IHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFN0cmVhbSB0aGF0IGNvbWJpbmVzIG1vdXNlbW92ZSBhbmQgbW91c2VvdmVyIGFuZCBvbmx5IGVtaXQgd2hlbiBtb3VzZSBnZXRzIGluIG9yIG91dCB0aGUgdHJhY2tcclxuICAgIC8vIE5PVEU6IHdlIG11c3QgdXNlIGEgQmVoYXZpb3JTdWJqZWN0IHRvIGdldCB0aGUgdmFsdWUgYXNhcCB0aGUgb25UcmFja0ZpcnN0Q2xpY2sgZnVuY3Rpb24gaXMgY2FsbGVkXHJcbiAgICBjb25zdCBtb3VzZU92ZXJUcmFjayQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3QodHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuIG1vdXNlRG93biQucGlwZShcclxuICAgICAgc3dpdGNoTWFwKChzdGFydEV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHN1YnNjcmliZSB0byBtb3VzZW1vdmUgYW5kIG1vdXNlb3V0IGV2ZW50cyBiZWZvcmUgY2FsbGluZyB0aGUgb25UcmFja0ZpcnN0Q2xpY2tcclxuICAgICAgICAvLyBCZWNhdXNlIHdlIG5lZWQgdG8gdGVsbCBpZiBtb3VzZSBpcyBvdmVyIG9yIG5vdCBhc2FwIHRoZSBmaXJzdCBmdW5jdGlvbiBpcyBkb25lXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB1c2VyIGNsaWNrIGZpcnN0IHRpbWUgYW5kIG1vdmVkIHRoZSBtb3VzZSBhd2F5IGltbWVkaWF0ZWx5LCB0aGUgbW91c2VvdXQgd2lsbCBub3QgYmUgZGV0ZWN0ZWRcclxuICAgICAgICBtZXJnZShtb3VzZU1vdmUkLCBtb3VzZU91dCQpLnBpcGUoXHJcbiAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICAgICAgdGFwKChvdmVyOiBib29sZWFuKSA9PiBtb3VzZU92ZXJUcmFjayQubmV4dChvdmVyKSksXHJcbiAgICAgICAgICB0YWtlVW50aWwobW91c2VVcCQpXHJcbiAgICAgICAgKS5zdWJzY3JpYmUoKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogVmVyaWZ5IGlmIHRoaXMgaXMgbmVlZGVkXHJcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgc3RvcCBwcm9wYWdhdGluZyB0aGUgbW92ZSBldmVudCB3aGVuIHBvaW50ZXIgaXMgbW92aW5nIG92ZXIgdGhlIHRodW1iXHJcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMudGh1bWIubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJtb3ZlJykucGlwZShcclxuICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgICAgICAgdGFrZVVudGlsKG1vdXNlVXAkKVxyXG4gICAgICAgICkuc3Vic2NyaWJlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm9uVHJhY2tGaXJzdENsaWNrKHN0YXJ0RXZlbnQpLnBpcGUoXHJcbiAgICAgICAgICBzd2l0Y2hNYXAoKGZpbmFsOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIElmIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgZGVzdGluYXRpb24gZnJvbSB0aGUgZmlyc3Qgc2Nyb2xsIGNhbGwsIGVuZCB0aGUgc3RyZWFtXHJcbiAgICAgICAgICAgIGlmIChmaW5hbCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFjdGl2YXRlIG1vdXNlbW92ZSBhbmQgbW91c2VvdXQgZXZlbnRzIGFuZCBzd2l0Y2ggdG8gb25nb2luZyBzY3JvbGwgY2FsbHNcclxuICAgICAgICAgICAgcmV0dXJuIG1vdXNlT3ZlclRyYWNrJC5waXBlKFxyXG4gICAgICAgICAgICAgIHN3aXRjaE1hcCgob3ZlcjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckRpcmVjdGlvbiA9IHRoaXMuZ2V0U2Nyb2xsRGlyZWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1lRGlyZWN0aW9uOiBib29sZWFuID0gdGhpcy5zY3JvbGxEaXJlY3Rpb24gPT09IGN1cnJEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBtb3VzZSBpcyBvdXQgdGhlIHRyYWNrIHBhdXNlIHRoZSBzY3JvbGwgY2FsbHMsIG90aGVyd2lzZSBrZWVwIGdvaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKG92ZXIgJiYgc2FtZURpcmVjdGlvbikgPyB0aGlzLm9uVHJhY2tPbmdvaW5nTW91c2Vkb3duKCkgOiBFTVBUWTtcclxuICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICBmaW5hbGl6ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgbW91c2VPdmVyVHJhY2skIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBtb3VzZU92ZXJUcmFjayQubmV4dCh0cnVlKTtcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICB0YWtlVW50aWwobW91c2VVcCQpLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgYWJzdHJhY3QgcmVhZG9ubHkgY3NzTGVuZ3RoUHJvcGVydHk6IHN0cmluZztcclxuXHJcbiAgYWJzdHJhY3QgcmVhZG9ubHkgY2xpZW50UHJvcGVydHk6IHN0cmluZztcclxuXHJcbiAgLy8gUmV0dXJucyB0aGUgdHJhY2sgc2l6ZSwgY2xpZW50SGVpZ2h0IG9yIGNsaWVudFdpZHRoXHJcbiAgYWJzdHJhY3QgZ2V0IHNpemUoKTogbnVtYmVyO1xyXG5cclxuICAvLyBSZXR1cm5zIHRoZSBzdGFydCBvZmZzZXQgZWl0aGVyICdjbGllbnRSZWN0LnRvcCcgb3IgJ2NsaWVudFJlY3QubGVmdCdcclxuICBhYnN0cmFjdCBnZXQgb2Zmc2V0KCk6IG51bWJlcjtcclxuXHJcbiAgLy8gR2V0IHRyYWNrIGNsaWVudCByZWN0XHJcbiAgZ2V0IGNsaWVudFJlY3QoKTogRE9NUmVjdCB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRTY3JvbGxEaXJlY3Rpb24oKTogJ2ZvcndhcmQnIHwgJ2JhY2t3YXJkJyB7XHJcbiAgICByZXR1cm4gdGhpcy5jdXJyTW91c2VQb3NpdGlvbiAtIHRoaXMudGh1bWIub2Zmc2V0ID4gMCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCc7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGVmZmVjdCgob25DbGVhbnVwOiBFZmZlY3RDbGVhbnVwUmVnaXN0ZXJGbikgPT4ge1xyXG4gICAgICBpZiAodGhpcy5jbXAuZGlzYWJsZVNlbnNvcigpKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDU1NWYXJpYWJsZXMoKTtcclxuICAgICAgICB0aGlzLnNpemVDaGFuZ2VTdWI/LnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zaXplQ2hhbmdlU3ViID0gcmVzaXplU2Vuc29yKHRoaXMubmF0aXZlRWxlbWVudCwgdGhpcy5jbXAuc2Vuc29yVGhyb3R0bGVUaW1lKCksIHRydWUpLnBpcGUoXHJcbiAgICAgICAgICB0YXAoKCkgPT4gdGhpcy51cGRhdGVDU1NWYXJpYWJsZXMoKSlcclxuICAgICAgICApLnN1YnNjcmliZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBvbkNsZWFudXAoKCkgPT4gdGhpcy5zaXplQ2hhbmdlU3ViPy51bnN1YnNjcmliZSgpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGVDU1NWYXJpYWJsZXMoKTogdm9pZCB7XHJcbiAgICB0aGlzLmNtcC5uYXRpdmVFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHRoaXMuY3NzTGVuZ3RoUHJvcGVydHksIGAkeyB0aGlzLnNpemUgfWApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xscyB0byBwb3NpdGlvbiB3aGVuIG1vdXNlIGlzIGRvd24gdGhlIG9uIHRoZSB0cmFjayB0aGUgZmlyc3QgdGltZVxyXG4gICAqL1xyXG4gIG9uVHJhY2tGaXJzdENsaWNrKGU6IFBvaW50ZXJFdmVudCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gICAgdGhpcy5jdXJyTW91c2VQb3NpdGlvbiA9IGVbdGhpcy5jbGllbnRQcm9wZXJ0eV07XHJcbiAgICAvLyBTYXZlIHNjcm9sbCBkaXJlY3Rpb25cclxuICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gdGhpcy5nZXRTY3JvbGxEaXJlY3Rpb24oKTtcclxuXHJcbiAgICBsZXQgdmFsdWU6IG51bWJlcjtcclxuICAgIGxldCBmaW5hbDogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBDaGVjayB3aGljaCBkaXJlY3Rpb24gc2hvdWxkIHRoZSBzY3JvbGwgZ28gKHVwIG9yIGRvd24pXHJcbiAgICBpZiAodGhpcy5zY3JvbGxEaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xyXG4gICAgICAvLyBTY3JvbGwgZG93blxyXG4gICAgICBjb25zdCBzY3JvbGxEb3duSW5jcmVtZW50OiBudW1iZXIgPSB0aGlzLnZpZXdwb3J0U2Nyb2xsT2Zmc2V0ICsgdGhpcy52aWV3cG9ydFZpZXdwb3J0U2l6ZTtcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluY3JlbWVudGFsIHBvc2l0aW9uIGlzIGJpZ2dlciB0aGFuIHRoZSBzY3JvbGwgbWF4XHJcbiAgICAgIGNvbnN0IHNjcm9sbE1heDogbnVtYmVyID0gdGhpcy52aWV3cG9ydFNjcm9sbFNpemUgLSB0aGlzLnZpZXdwb3J0Vmlld3BvcnRTaXplO1xyXG4gICAgICBpZiAoc2Nyb2xsRG93bkluY3JlbWVudCA+PSBzY3JvbGxNYXgpIHtcclxuICAgICAgICB2YWx1ZSA9IHNjcm9sbE1heDtcclxuICAgICAgICBmaW5hbCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSBzY3JvbGxEb3duSW5jcmVtZW50O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTY3JvbGwgdXBcclxuICAgICAgY29uc3Qgc2Nyb2xsVXBJbmNyZW1lbnQ6IG51bWJlciA9IHRoaXMudmlld3BvcnRTY3JvbGxPZmZzZXQgLSB0aGlzLnZpZXdwb3J0Vmlld3BvcnRTaXplO1xyXG4gICAgICBpZiAoc2Nyb2xsVXBJbmNyZW1lbnQgPD0gMCkge1xyXG4gICAgICAgIHZhbHVlID0gMDtcclxuICAgICAgICBmaW5hbCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSBzY3JvbGxVcEluY3JlbWVudDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnNjcm9sbFRvKHZhbHVlKS5waXBlKFxyXG4gICAgICBkZWxheSgyMDApLFxyXG4gICAgICBtYXAoKCkgPT4gZmluYWwpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBtb3VzZSBpcyBzdGlsbCBkb3duIG9uIHRoZSB0cmFja1xyXG4gICAqL1xyXG4gIG9uVHJhY2tPbmdvaW5nTW91c2Vkb3duKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gICAgY29uc3Qgc2Nyb2xsRmluYWw6IG51bWJlciA9IHRoaXMuZ2V0UmVsYXRpdmVQb3NpdGlvbigpO1xyXG5cclxuICAgIGxldCB2YWx1ZTogbnVtYmVyO1xyXG4gICAgbGV0IGZpbmFsOiBib29sZWFuO1xyXG5cclxuICAgIC8vIENoZWNrIHdoaWNoIGRpcmVjdGlvbiBzaG91bGQgdGhlIHNjcm9sbCBnbyAodXAgb3IgZG93bilcclxuICAgIGlmICh0aGlzLnNjcm9sbERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XHJcbiAgICAgIC8vIFNjcm9sbCBkb3duXHJcbiAgICAgIGNvbnN0IHNjcm9sbERvd25JbmNyZW1lbnQ6IG51bWJlciA9IHRoaXMudmlld3BvcnRTY3JvbGxPZmZzZXQgKyB0aGlzLnZpZXdwb3J0Vmlld3BvcnRTaXplO1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgaW5jcmVtZW50YWwgcG9zaXRpb24gaXMgYmlnZ2VyIHRoYW4gdGhlIHNjcm9sbCBtYXhcclxuICAgICAgaWYgKHNjcm9sbERvd25JbmNyZW1lbnQgPj0gc2Nyb2xsRmluYWwpIHtcclxuICAgICAgICB2YWx1ZSA9IHNjcm9sbEZpbmFsO1xyXG4gICAgICAgIGZpbmFsID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YWx1ZSA9IHNjcm9sbERvd25JbmNyZW1lbnQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFNjcm9sbCB1cFxyXG4gICAgICBjb25zdCBzY3JvbGxVcEluY3JlbWVudDogbnVtYmVyID0gdGhpcy52aWV3cG9ydFNjcm9sbE9mZnNldCAtIHRoaXMudmlld3BvcnRWaWV3cG9ydFNpemU7XHJcbiAgICAgIGlmIChzY3JvbGxVcEluY3JlbWVudCA8PSBzY3JvbGxGaW5hbCkge1xyXG4gICAgICAgIHZhbHVlID0gc2Nyb2xsRmluYWw7XHJcbiAgICAgICAgZmluYWwgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gc2Nyb2xsVXBJbmNyZW1lbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxUbyh2YWx1ZSkucGlwZShcclxuICAgICAgdGFrZVdoaWxlKCgpID0+ICFmaW5hbCksXHJcbiAgICAgIGV4cGFuZCgoKSA9PiB0aGlzLm9uVHJhY2tPbmdvaW5nTW91c2Vkb3duKCkpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRSZWxhdGl2ZVBvc2l0aW9uKCk6IG51bWJlciB7XHJcbiAgICBjb25zdCBjbGlja1Bvc2l0aW9uOiBudW1iZXIgPSB0aGlzLmN1cnJNb3VzZVBvc2l0aW9uIC0gdGhpcy5vZmZzZXQ7XHJcbiAgICBjb25zdCBjdXJyZW50OiBudW1iZXIgPSBjbGlja1Bvc2l0aW9uIC8gdGhpcy5zaXplO1xyXG4gICAgcmV0dXJuIGN1cnJlbnQgKiAodGhpcy52aWV3cG9ydFNjcm9sbFNpemUgLSB0aGlzLnZpZXdwb3J0Vmlld3BvcnRTaXplKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzY3JvbGxUbyhwb3NpdGlvbjogbnVtYmVyKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG4iXX0=