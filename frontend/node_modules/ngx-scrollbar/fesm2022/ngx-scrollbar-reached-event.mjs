import * as i0 from '@angular/core';
import { inject, PLATFORM_ID, NgZone, Renderer2, Injector, signal, EventEmitter, runInInjectionContext, effect, numberAttribute, booleanAttribute, Directive, Input, Output, NgModule } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { NG_SCROLLBAR } from 'ngx-scrollbar';

class NgScrollbarReached {
    constructor() {
        this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
        this.zone = inject(NgZone);
        this.renderer = inject(Renderer2);
        this.injector = inject(Injector);
        this.scrollbar = inject(NG_SCROLLBAR);
        this.disabled = signal(false);
        /** An array that contains all trigger elements  **/
        this.triggerElements = [];
        /** An array that contains the chosen outputs */
        this.subscribedEvents = [];
        this.reachedTop = new EventEmitter();
        this.reachedBottom = new EventEmitter();
        this.reachedStart = new EventEmitter();
        this.reachedEnd = new EventEmitter();
        /** A mapper function to ease forwarding the intersected element to its proper output */
        this.reachedEventActions = {
            top: { emit: () => this.scrollbar.isVerticallyScrollable() ? this.reachedTop.emit() : null },
            bottom: { emit: () => this.scrollbar.isVerticallyScrollable() ? this.reachedBottom.emit() : null },
            start: { emit: () => this.scrollbar.isHorizontallyScrollable() ? this.reachedStart.emit() : null },
            end: { emit: () => this.scrollbar.isHorizontallyScrollable() ? this.reachedEnd.emit() : null }
        };
    }
    /** Reached offset value in px */
    set offsetSetter(value) {
        this.setCssVariable('--reached-offset', value);
    }
    set offsetTopSetter(value) {
        this.setCssVariable('--reached-offset-top', value);
    }
    set offsetBottomSetter(value) {
        this.setCssVariable('--reached-offset-bottom', value);
    }
    set offsetStartSetter(value) {
        this.setCssVariable('--reached-offset-start', value);
    }
    set offsetEndSetter(value) {
        this.setCssVariable('--reached-offset-end', value);
    }
    set disableReachedSetter(value) {
        this.disabled.set(value);
    }
    onReached(trigger) {
        if (trigger) {
            this.reachedEventActions[trigger]?.emit();
        }
    }
    activate() {
        this.zone.runOutsideAngular(() => {
            // Create the scrollbars element inside the viewport
            this.triggerElementsWrapper = this.renderer.createElement('div');
            this.renderer.addClass(this.triggerElementsWrapper, 'ng-scroll-reached-wrapper');
            this.renderer.appendChild(this.scrollbar.viewport.contentWrapperElement, this.triggerElementsWrapper);
            // Create a trigger element for each subscribed event
            this.subscribedEvents.forEach((event) => {
                const triggerElement = this.renderer.createElement('div');
                this.renderer.addClass(triggerElement, 'scroll-reached-trigger-element');
                this.renderer.setAttribute(triggerElement, 'trigger', event);
                this.renderer.appendChild(this.triggerElementsWrapper, triggerElement);
                this.triggerElements.push(triggerElement);
            });
            // The first time the observer is triggered as soon as the element is observed,
            // This flag is used to ignore this first trigger
            let intersectionObserverInit = false;
            this.intersectionObserver = new IntersectionObserver((entries) => {
                if (intersectionObserverInit) {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            // Forward the detected trigger element only after the observer is initialized
                            // Only observe the trigger elements when scrollable
                            this.zone.run(() => this.onReached(entry.target.getAttribute('trigger')));
                        }
                    });
                }
                else {
                    // Once the initial element is detected set a flag to true
                    intersectionObserverInit = true;
                }
            }, {
                root: this.scrollbar.viewport.nativeElement,
            });
            this.triggerElements.forEach((el) => this.intersectionObserver.observe(el));
        });
    }
    deactivate() {
        this.intersectionObserver?.disconnect();
        this.triggerElementsWrapper?.remove();
        this.triggerElements = [];
    }
    setCssVariable(property, value) {
        if (value) {
            this.scrollbar.nativeElement.style.setProperty(property, `${value}px`);
        }
    }
    ngOnInit() {
        if (this.reachedTop.observed) {
            this.subscribedEvents.push('top');
        }
        if (this.reachedBottom.observed) {
            this.subscribedEvents.push('bottom');
        }
        if (this.reachedStart.observed) {
            this.subscribedEvents.push('start');
        }
        if (this.reachedBottom.observed) {
            this.subscribedEvents.push('end');
        }
        runInInjectionContext(this.injector, () => {
            effect(() => {
                if (this.disabled()) {
                    this.deactivate();
                }
                else {
                    if (this.isBrowser) {
                        this.activate();
                    }
                }
            });
        });
    }
    ngOnDestroy() {
        this.deactivate();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarReached, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.2.1", type: NgScrollbarReached, isStandalone: true, selector: "ng-scrollbar[reachedTop], ng-scrollbar[reachedBottom], ng-scrollbar[reachedStart], ng-scrollbar[reachedEnd]", inputs: { offsetSetter: ["reachedOffset", "offsetSetter", numberAttribute], offsetTopSetter: ["reachedTopOffset", "offsetTopSetter", numberAttribute], offsetBottomSetter: ["reachedBottomOffset", "offsetBottomSetter", numberAttribute], offsetStartSetter: ["reachedStartOffset", "offsetStartSetter", numberAttribute], offsetEndSetter: ["reachedEndOffset", "offsetEndSetter", numberAttribute], disableReachedSetter: ["disableReached", "disableReachedSetter", booleanAttribute] }, outputs: { reachedTop: "reachedTop", reachedBottom: "reachedBottom", reachedStart: "reachedStart", reachedEnd: "reachedEnd" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarReached, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ng-scrollbar[reachedTop], ng-scrollbar[reachedBottom], ng-scrollbar[reachedStart], ng-scrollbar[reachedEnd]',
                    standalone: true,
                }]
        }], propDecorators: { offsetSetter: [{
                type: Input,
                args: [{ alias: 'reachedOffset', transform: numberAttribute }]
            }], offsetTopSetter: [{
                type: Input,
                args: [{ alias: 'reachedTopOffset', transform: numberAttribute }]
            }], offsetBottomSetter: [{
                type: Input,
                args: [{ alias: 'reachedBottomOffset', transform: numberAttribute }]
            }], offsetStartSetter: [{
                type: Input,
                args: [{ alias: 'reachedStartOffset', transform: numberAttribute }]
            }], offsetEndSetter: [{
                type: Input,
                args: [{ alias: 'reachedEndOffset', transform: numberAttribute }]
            }], disableReachedSetter: [{
                type: Input,
                args: [{ alias: 'disableReached', transform: booleanAttribute }]
            }], reachedTop: [{
                type: Output
            }], reachedBottom: [{
                type: Output
            }], reachedStart: [{
                type: Output
            }], reachedEnd: [{
                type: Output
            }] } });

class NgScrollbarReachedModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarReachedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarReachedModule, imports: [NgScrollbarReached], exports: [NgScrollbarReached] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarReachedModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarReachedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        NgScrollbarReached
                    ],
                    exports: [
                        NgScrollbarReached
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgScrollbarReached, NgScrollbarReachedModule };
//# sourceMappingURL=ngx-scrollbar-reached-event.mjs.map
