import * as i0 from '@angular/core';
import { InjectionToken, inject, ElementRef, Directive, PLATFORM_ID, signal, Injectable, Optional, Inject, NgZone, Injector, input, booleanAttribute, computed, numberAttribute, EventEmitter, runInInjectionContext, effect, Input, Output, ContentChild, ViewChild, Component, ChangeDetectionStrategy, ApplicationRef, ComponentFactoryResolver, NgModule } from '@angular/core';
import { Observable, throttleTime, map, tap, fromEvent, switchMap, of, takeUntil, BehaviorSubject, merge, distinctUntilChanged, EMPTY, finalize, delay, takeWhile, expand } from 'rxjs';
import { getRtlScrollAxisType, Platform, RtlScrollAxisType } from '@angular/cdk/platform';
import { Directionality } from '@angular/cdk/bidi';
import { toSignal } from '@angular/core/rxjs-interop';
import { SmoothScrollManager } from 'ngx-scrollbar/smooth-scroll';
import { isPlatformBrowser, DOCUMENT } from '@angular/common';
import { fromPromise } from 'rxjs/internal/observable/innerFrom';

var ScrollbarUpdateReason;
(function (ScrollbarUpdateReason) {
    ScrollbarUpdateReason["AfterInit"] = "AfterInit";
    ScrollbarUpdateReason["Resized"] = "ResizeObserver";
})(ScrollbarUpdateReason || (ScrollbarUpdateReason = {}));
const NG_SCROLLBAR_OPTIONS = new InjectionToken('NG_SCROLLBAR_OPTIONS');
var ViewportClasses;
(function (ViewportClasses) {
    ViewportClasses["Viewport"] = "ng-scroll-viewport";
    ViewportClasses["Content"] = "ng-scroll-content";
})(ViewportClasses || (ViewportClasses = {}));

class ViewportAdapter {
    /** Viewport clientHeight */
    get offsetHeight() {
        return this.nativeElement.offsetHeight;
    }
    /** Viewport clientWidth */
    get offsetWidth() {
        return this.nativeElement.offsetWidth;
    }
    /** Viewport scrollTop */
    get scrollTop() {
        return this.nativeElement.scrollTop;
    }
    /** Viewport scrollLeft */
    get scrollLeft() {
        return this.nativeElement.scrollLeft;
    }
    /** Content height, falls back to scroll height */
    get contentHeight() {
        return this.contentWrapperElement?.offsetHeight;
    }
    /** Content width, falls back to scroll height */
    get contentWidth() {
        return this.contentWrapperElement?.offsetWidth;
    }
    /** The horizontal remaining scrollable distance */
    get scrollMaxX() {
        return this.contentWidth - this.offsetWidth;
    }
    /** The vertical remaining scrollable distance */
    get scrollMaxY() {
        return this.contentHeight - this.offsetHeight;
    }
    constructor(nativeElement) {
        this.nativeElement = nativeElement;
        nativeElement.classList.add(ViewportClasses.Viewport);
    }
    /**
     * Initialize viewport
     */
    init(contentSelector, spacerSelector) {
        // When integrating the scrollbar with virtual scroll, the content wrapper will have fake size,
        // and a spacer element will have the real size
        // Therefore, if spaceElement is provided, it will be observed instead of the content wrapper
        if (spacerSelector) {
            // Set relative position on the spacer element to enable the functionality of sticky for the scrollbars
            spacerSelector.style.position = 'relative';
            this.contentWrapperElement = spacerSelector;
        }
        let realContentWrapper = contentSelector ?? this.nativeElement?.firstElementChild;
        // Add content wrapper class
        realContentWrapper?.classList.add(ViewportClasses.Content);
        // If spacer is not provided, set it as the content wrapper
        if (!this.contentWrapperElement && realContentWrapper) {
            this.contentWrapperElement = realContentWrapper;
        }
    }
    /**
     * Scroll viewport vertically
     */
    scrollYTo(value) {
        this.nativeElement.scrollTop = value;
    }
    /**
     * Scroll viewport horizontally
     */
    scrollXTo(value) {
        this.nativeElement.scrollLeft = value;
    }
}

class ScrollViewport {
    constructor() {
        this.viewport = new ViewportAdapter(inject((ElementRef)).nativeElement);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollViewport, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.1", type: ScrollViewport, isStandalone: true, selector: "[scrollViewport]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollViewport, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[scrollViewport]'
                }]
        }] });

function resizeSensor(element, throttleDuration, isScrollbar) {
    // The first time the observer is triggered as soon as the element is observed,
    // So we need to differentiate the reason of the event fired
    let reason = ScrollbarUpdateReason.AfterInit;
    let resizeObserver;
    const stream = new Observable((observer) => {
        resizeObserver = new ResizeObserver(() => {
            observer.next(reason);
            // After first init event, mark the reason to be a resize from now on.
            reason = ScrollbarUpdateReason.Resized;
        });
        resizeObserver.observe(element);
        // If a content element has a supporting content scrollbars, observe it!
        if (!isScrollbar && element.firstElementChild) {
            resizeObserver.observe(element.firstElementChild);
        }
        return () => {
            resizeObserver?.disconnect();
        };
    });
    return throttleDuration ? stream.pipe(throttleTime(throttleDuration, null, {
        leading: true,
        trailing: true
    })) : stream;
}

/**
 * Injection token that can be used to query for a `NgScrollbar`.
 * Used primarily to avoid circular imports.
 */
const NG_SCROLLBAR = new InjectionToken('_NG_SCROLLBAR');

const defaultOptions = {
    scrollTimelinePolyfill: 'https://flackr.github.io/scroll-timeline/dist/scroll-timeline.js',
    trackClass: '',
    thumbClass: '',
    orientation: 'auto',
    appearance: 'standard',
    visibility: 'native',
    position: 'native',
    clickScrollDuration: 50,
    sensorThrottleTime: 0,
    disableSensor: false,
    disableInteraction: false
};
class ScrollbarManager {
    constructor(options) {
        this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
        this.document = inject(DOCUMENT);
        this.window = this.document.defaultView;
        this.globalOptions = {};
        this.rtlScrollAxisType = getRtlScrollAxisType();
        this.scrollTimelinePolyfill = signal(null);
        this.globalOptions = options ? { ...defaultOptions, ...options } : defaultOptions;
        if (this.isBrowser && !this.window['ScrollTimeline'] && !CSS.supports('animation-timeline', 'scroll()')) {
            this.initPolyfill();
        }
    }
    async initPolyfill() {
        try {
            // Create a script element
            const script = this.document.createElement('script');
            script.src = this.globalOptions.scrollTimelinePolyfill;
            // Wait for the script to load
            await new Promise((resolve, reject) => {
                script.onload = resolve;
                script.onerror = reject;
                this.document.head.appendChild(script);
            });
            // Once loaded, access and execute the function attached to the window object
            if (this.window['ScrollTimeline']) {
                this.scrollTimelinePolyfill.set(window['ScrollTimeline']);
            }
            else {
                console.error('ScrollTimeline is not attached to the window object.');
            }
        }
        catch (error) {
            console.error('Error loading ScrollTimeline script:', error);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollbarManager, deps: [{ token: NG_SCROLLBAR_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollbarManager, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollbarManager, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [NG_SCROLLBAR_OPTIONS]
                }] }] });

class NgScrollbarCore {
    constructor() {
        this.platform = inject(Platform);
        this.zone = inject(NgZone);
        this.injector = inject(Injector);
        this.isMobile = this.platform.SAFARI || this.platform.ANDROID;
        this.dir = inject(Directionality);
        this.manager = inject(ScrollbarManager);
        this.smoothScroll = inject(SmoothScrollManager);
        this.nativeElement = inject((ElementRef)).nativeElement;
        this.rtlScrollAxisType = this.manager.rtlScrollAxisType;
        /**
         * Indicates when scrollbar thumb is being dragged
         */
        this.dragging = signal('none');
        /**
         * Sets the supported scroll track of the viewport, there are 3 options:
         *
         * - `vertical` Use both vertical and horizontal scrollbar
         * - `horizontal` Use both vertical and horizontal scrollbar
         * - `auto` Use both vertical and horizontal scrollbar
         */
        this.orientation = input(this.manager.globalOptions.orientation);
        /**
         * When to show the scrollbar, and there are 3 options:
         *
         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
         * - `always` Scrollbars are always shown even if the viewport is not scrollable
         */
        this.visibility = input(this.manager.globalOptions.visibility);
        /** Disables scrollbar interaction like dragging thumb and jumping by track click */
        this.disableInteraction = input(this.manager.globalOptions.disableInteraction, {
            transform: booleanAttribute
        });
        /** A computed signal for disabling the interaction */
        this.interactionDisabled = computed(() => {
            return this.isMobile || this.disableInteraction();
        });
        /** Whether ResizeObserver is disabled */
        this.disableSensor = input(this.manager.globalOptions.disableSensor, {
            transform: booleanAttribute
        });
        /** Throttle interval for detecting changes via ResizeObserver */
        this.sensorThrottleTime = input(this.manager.globalOptions.sensorThrottleTime, {
            transform: numberAttribute
        });
        this.viewportDimension = signal({
            contentHeight: 0,
            contentWidth: 0,
            offsetHeight: 0,
            offsetWidth: 0
        });
        this.state = computed(() => {
            let verticalUsed = false;
            let horizontalUsed = false;
            let isVerticallyScrollable = false;
            let isHorizontallyScrollable = false;
            const orientation = this.orientation();
            const visibility = this.visibility();
            const viewport = this.viewportDimension();
            // Check if vertical scrollbar should be displayed
            if (orientation === 'auto' || orientation === 'vertical') {
                isVerticallyScrollable = viewport.contentHeight > viewport.offsetHeight;
                verticalUsed = visibility === 'always' || isVerticallyScrollable;
            }
            // Check if horizontal scrollbar should be displayed
            if (orientation === 'auto' || orientation === 'horizontal') {
                isHorizontallyScrollable = viewport.contentWidth > viewport.offsetWidth;
                horizontalUsed = visibility === 'always' || isHorizontallyScrollable;
            }
            return {
                verticalUsed,
                horizontalUsed,
                isVerticallyScrollable,
                isHorizontallyScrollable,
            };
        });
        this.isVerticallyScrollable = computed(() => this.state().isVerticallyScrollable);
        this.isHorizontallyScrollable = computed(() => this.state().isHorizontallyScrollable);
        this.verticalUsed = computed(() => this.state().verticalUsed);
        this.horizontalUsed = computed(() => this.state().horizontalUsed);
        /** Scroll duration when the scroll track is clicked */
        this.trackClickDuration = this.manager.globalOptions.clickScrollDuration;
        /**
         *  Sets the appearance of the scrollbar, there are 2 options:
         *
         * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
         */
        this.appearance = this.manager.globalOptions.appearance;
        /**
         * Sets the position of each scrollbar, there are 4 options:
         *
         * - `native` (Default) Use the default position like in native scrollbar.
         * - `invertY` Inverts vertical scrollbar position
         * - `invertX` Inverts Horizontal scrollbar position
         * - `invertAll` Inverts both scrollbar positions
         */
        this.position = this.manager.globalOptions.position;
        /** A class forwarded to the scrollbar track element */
        this.trackClass = this.manager.globalOptions.trackClass;
        /** A class forwarded to the scrollbar thumb element */
        this.thumbClass = this.manager.globalOptions.thumbClass;
        /** Steam that emits when scrollbar is initialized */
        this.afterInit = new EventEmitter();
        /** Steam that emits when scrollbar is updated */
        this.afterUpdate = new EventEmitter();
    }
    ngOnInit() {
        runInInjectionContext(this.injector, () => {
            // The direction signal cannot be initialized in the constructor
            // Because it initially returns 'ltr' even if dir.value is 'rtl`
            this.direction = toSignal(this.dir.change.pipe(map(() => this.dir.value)), { initialValue: this.dir.value });
            effect((onCleanup) => {
                // Check whether sensor should be enabled
                if (this.disableSensor()) {
                    // If sensor is disabled update manually
                    this.sizeChangeSub?.unsubscribe();
                }
                else {
                    if (this.platform.isBrowser) {
                        this.sizeChangeSub?.unsubscribe();
                        this.sizeChangeSub = resizeSensor(this.viewport.nativeElement, this.sensorThrottleTime()).pipe(tap((reason) => this.update(reason))).subscribe();
                    }
                }
                onCleanup(() => this.sizeChangeSub?.unsubscribe());
            });
        });
    }
    ngAfterViewInit() {
        // If sensor is disabled, update to evaluate the state
        if (this.platform.isBrowser && this.disableSensor()) {
            // In case of 3rd party library, need to wait for content to be rendered
            requestAnimationFrame(() => {
                this.update(ScrollbarUpdateReason.AfterInit);
            });
        }
    }
    /**
     * Update local state and the internal scrollbar controls
     */
    update(reason) {
        this.updateCSSVariables();
        this.zone.run(() => {
            this.viewportDimension.set({
                contentHeight: this.viewport.contentHeight,
                contentWidth: this.viewport.contentWidth,
                offsetHeight: this.viewport.offsetHeight,
                offsetWidth: this.viewport.offsetWidth
            });
            if (reason === ScrollbarUpdateReason.AfterInit) {
                this.afterInit.emit();
            }
            else {
                this.afterUpdate.emit();
            }
        });
    }
    /**
     * Smooth scroll functions
     */
    scrollTo(options) {
        return this.smoothScroll.scrollTo(this.viewport.nativeElement, {
            duration: this.trackClickDuration,
            ...options
        });
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(target, options) {
        return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);
    }
    /**
     * Update Essential CSS variables
     */
    updateCSSVariables() {
        this.nativeElement.style.setProperty('--content-height', `${this.viewport.contentHeight}`);
        this.nativeElement.style.setProperty('--content-width', `${this.viewport.contentWidth}`);
        this.nativeElement.style.setProperty('--viewport-height', `${this.viewport.offsetHeight}`);
        this.nativeElement.style.setProperty('--viewport-width', `${this.viewport.offsetWidth}`);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarCore, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "17.2.1", type: NgScrollbarCore, inputs: { orientation: { classPropertyName: "orientation", publicName: "orientation", isSignal: true, isRequired: false, transformFunction: null }, visibility: { classPropertyName: "visibility", publicName: "visibility", isSignal: true, isRequired: false, transformFunction: null }, disableInteraction: { classPropertyName: "disableInteraction", publicName: "disableInteraction", isSignal: true, isRequired: false, transformFunction: null }, disableSensor: { classPropertyName: "disableSensor", publicName: "disableSensor", isSignal: true, isRequired: false, transformFunction: null }, sensorThrottleTime: { classPropertyName: "sensorThrottleTime", publicName: "sensorThrottleTime", isSignal: true, isRequired: false, transformFunction: null }, trackClickDuration: { classPropertyName: "trackClickDuration", publicName: "clickScrollDuration", isSignal: false, isRequired: false, transformFunction: numberAttribute }, appearance: { classPropertyName: "appearance", publicName: "appearance", isSignal: false, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: false, isRequired: false, transformFunction: null }, trackClass: { classPropertyName: "trackClass", publicName: "trackClass", isSignal: false, isRequired: false, transformFunction: null }, thumbClass: { classPropertyName: "thumbClass", publicName: "thumbClass", isSignal: false, isRequired: false, transformFunction: null } }, outputs: { afterInit: "afterInit", afterUpdate: "afterUpdate" }, host: { properties: { "class.ng-scrollbar": "true", "attr.verticalUsed": "verticalUsed()", "attr.horizontalUsed": "horizontalUsed()", "attr.isVerticallyScrollable": "isVerticallyScrollable()", "attr.isHorizontallyScrollable": "isHorizontallyScrollable()", "attr.mobile": "isMobile", "attr.dir": "direction()", "attr.position": "position", "attr.dragging": "dragging()", "attr.appearance": "appearance", "attr.visibility": "visibility()", "attr.orientation": "orientation()", "attr.disableInteraction": "interactionDisabled()" } }, providers: [{ provide: NG_SCROLLBAR, useExisting: NgScrollbarCore }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarCore, decorators: [{
            type: Directive,
            args: [{
                    host: {
                        '[class.ng-scrollbar]': 'true',
                        '[attr.verticalUsed]': 'verticalUsed()',
                        '[attr.horizontalUsed]': 'horizontalUsed()',
                        '[attr.isVerticallyScrollable]': 'isVerticallyScrollable()',
                        '[attr.isHorizontallyScrollable]': 'isHorizontallyScrollable()',
                        '[attr.mobile]': 'isMobile',
                        '[attr.dir]': 'direction()',
                        '[attr.position]': 'position',
                        '[attr.dragging]': 'dragging()',
                        '[attr.appearance]': 'appearance',
                        '[attr.visibility]': 'visibility()',
                        '[attr.orientation]': 'orientation()',
                        '[attr.disableInteraction]': 'interactionDisabled()'
                    },
                    providers: [{ provide: NG_SCROLLBAR, useExisting: NgScrollbarCore }]
                }]
        }], propDecorators: { trackClickDuration: [{
                type: Input,
                args: [{
                        alias: 'clickScrollDuration',
                        transform: numberAttribute
                    }]
            }], appearance: [{
                type: Input
            }], position: [{
                type: Input
            }], trackClass: [{
                type: Input
            }], thumbClass: [{
                type: Input
            }], afterInit: [{
                type: Output
            }], afterUpdate: [{
                type: Output
            }] } });

function preventSelection(doc) {
    return tap(() => doc.onselectstart = () => false);
}
function enableSelection(doc) {
    return tap(() => doc.onselectstart = null);
}
function stopPropagation() {
    return tap((e) => {
        // Have to prevent default to avoid unexpected movement whe you grab object beneath scrollbar #476
        // https://github.com/MurhafSousli/ngx-scrollbar/issues/476
        e.preventDefault();
        e.stopPropagation();
    });
}

// @dynamic
class ThumbAdapter {
    get trackMax() {
        return this.track.size - this.size;
    }
    // Get thumb client rect
    get clientRect() {
        return this.nativeElement.getBoundingClientRect();
    }
    /**
     * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
     * This function is called by thumb drag event using viewport or scrollbar pointer events
     */
    get dragged() {
        return fromEvent(this.nativeElement, 'pointerdown').pipe(stopPropagation(), switchMap((e) => {
            let trackMaxStart;
            let scrollMaxStart;
            const dragStart = of(e).pipe(preventSelection(this.document), tap(() => {
                // Capture scrollMax and trackMax once
                trackMaxStart = this.trackMax;
                scrollMaxStart = this.viewportScrollMax;
                this.setDragging(this.axis);
            }));
            const dragging = fromEvent(this.document, 'pointermove').pipe(stopPropagation());
            const dragEnd = fromEvent(this.document, 'pointerup', { capture: true }).pipe(stopPropagation(), enableSelection(this.document), tap(() => this.setDragging('none')));
            return dragStart.pipe(map((e) => e[this.pageProperty]), map((pageOffset) => pageOffset - this.dragStartOffset), switchMap((mouseDownOffset) => dragging.pipe(map((e) => e[this.clientProperty]), 
            // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).
            map((mouseOffset) => mouseOffset - this.track.offset), map((offset) => scrollMaxStart * (offset - mouseDownOffset) / trackMaxStart), map((position) => this.handleDrag(position, scrollMaxStart)), tap((position) => this.scrollTo(position)), takeUntil(dragEnd))));
        }));
    }
    constructor() {
        this.zone = inject(NgZone);
        this.document = inject(DOCUMENT);
        this.cmp = inject(NG_SCROLLBAR);
        this.manager = inject(ScrollbarManager);
        this.track = inject(TrackAdapter);
        this.nativeElement = inject((ElementRef)).nativeElement;
        effect(() => {
            const script = this.manager.scrollTimelinePolyfill();
            if (script && !this.animation) {
                this.animation = startPolyfill(script, this.nativeElement, this.cmp.viewport.nativeElement, this.axis);
            }
        });
    }
    setDragging(value) {
        this.zone.run(() => this.cmp.dragging.set(value));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ThumbAdapter, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.1", type: ThumbAdapter, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ThumbAdapter, decorators: [{
            type: Directive
        }], ctorParameters: () => [] });
function startPolyfill(ScrollTimeline, element, source, axis) {
    return element.animate({
        translate: [
            'var(--_scrollbar-thumb-transform-from)',
            'var(--_scrollbar-thumb-transform-to)'
        ]
    }, {
        fill: 'both',
        easing: 'linear',
        timeline: new ScrollTimeline({ source, axis })
    });
}

// @dynamic
class TrackAdapter {
    get dragged() {
        const mouseDown$ = fromEvent(this.nativeElement, 'pointerdown').pipe(stopPropagation(), preventSelection(this.document));
        const mouseUp$ = fromEvent(this.document, 'pointerup', { passive: true }).pipe(enableSelection(this.document));
        // The reason why we use mousemove instead of mouseover, that we need to save the current mouse location
        const mouseMove$ = fromEvent(this.nativeElement, 'pointermove', { passive: true }).pipe(map((e) => {
            this.currMousePosition = e[this.clientProperty];
            return true;
        }));
        const mouseOut$ = fromEvent(this.nativeElement, 'pointerout', { passive: true }).pipe(map(() => {
            return false;
        }));
        // Stream that combines mousemove and mouseover and only emit when mouse gets in or out the track
        // NOTE: we must use a BehaviorSubject to get the value asap the onTrackFirstClick function is called
        const mouseOverTrack$ = new BehaviorSubject(true);
        return mouseDown$.pipe(switchMap((startEvent) => {
            // We need to subscribe to mousemove and mouseout events before calling the onTrackFirstClick
            // Because we need to tell if mouse is over or not asap the first function is done
            // Otherwise, if user click first time and moved the mouse away immediately, the mouseout will not be detected
            merge(mouseMove$, mouseOut$).pipe(distinctUntilChanged(), tap((over) => mouseOverTrack$.next(over)), takeUntil(mouseUp$)).subscribe();
            // TODO: Verify if this is needed
            // This should stop propagating the move event when pointer is moving over the thumb
            fromEvent(this.thumb.nativeElement, 'pointermove').pipe(stopPropagation(), takeUntil(mouseUp$)).subscribe();
            return this.onTrackFirstClick(startEvent).pipe(switchMap((final) => {
                // If scroll has reached the destination from the first scroll call, end the stream
                if (final) {
                    return EMPTY;
                }
                // Otherwise, activate mousemove and mouseout events and switch to ongoing scroll calls
                return mouseOverTrack$.pipe(switchMap((over) => {
                    const currDirection = this.getScrollDirection();
                    const sameDirection = this.scrollDirection === currDirection;
                    // If mouse is out the track pause the scroll calls, otherwise keep going
                    return (over && sameDirection) ? this.onTrackOngoingMousedown() : EMPTY;
                }), finalize(() => {
                    // Reset the mouseOverTrack$ state
                    mouseOverTrack$.next(true);
                }));
            }), takeUntil(mouseUp$));
        }));
    }
    // Get track client rect
    get clientRect() {
        return this.nativeElement.getBoundingClientRect();
    }
    getScrollDirection() {
        return this.currMousePosition - this.thumb.offset > 0 ? 'forward' : 'backward';
    }
    constructor() {
        this.nativeElement = inject((ElementRef)).nativeElement;
        this.cmp = inject(NG_SCROLLBAR);
        this.document = inject(DOCUMENT);
        effect((onCleanup) => {
            if (this.cmp.disableSensor()) {
                this.updateCSSVariables();
                this.sizeChangeSub?.unsubscribe();
            }
            else {
                this.sizeChangeSub = resizeSensor(this.nativeElement, this.cmp.sensorThrottleTime(), true).pipe(tap(() => this.updateCSSVariables())).subscribe();
            }
            onCleanup(() => this.sizeChangeSub?.unsubscribe());
        });
    }
    updateCSSVariables() {
        this.cmp.nativeElement.style.setProperty(this.cssLengthProperty, `${this.size}`);
    }
    /**
     * Scrolls to position when mouse is down the on the track the first time
     */
    onTrackFirstClick(e) {
        this.currMousePosition = e[this.clientProperty];
        // Save scroll direction
        this.scrollDirection = this.getScrollDirection();
        let value;
        let final;
        // Check which direction should the scroll go (up or down)
        if (this.scrollDirection === 'forward') {
            // Scroll down
            const scrollDownIncrement = this.viewportScrollOffset + this.viewportViewportSize;
            // Check if the incremental position is bigger than the scroll max
            const scrollMax = this.viewportScrollSize - this.viewportViewportSize;
            if (scrollDownIncrement >= scrollMax) {
                value = scrollMax;
                final = true;
            }
            else {
                value = scrollDownIncrement;
            }
        }
        else {
            // Scroll up
            const scrollUpIncrement = this.viewportScrollOffset - this.viewportViewportSize;
            if (scrollUpIncrement <= 0) {
                value = 0;
                final = true;
            }
            else {
                value = scrollUpIncrement;
            }
        }
        return this.scrollTo(value).pipe(delay(200), map(() => final));
    }
    /**
     * Callback that is called when mouse is still down on the track
     */
    onTrackOngoingMousedown() {
        const scrollFinal = this.getRelativePosition();
        let value;
        let final;
        // Check which direction should the scroll go (up or down)
        if (this.scrollDirection === 'forward') {
            // Scroll down
            const scrollDownIncrement = this.viewportScrollOffset + this.viewportViewportSize;
            // Check if the incremental position is bigger than the scroll max
            if (scrollDownIncrement >= scrollFinal) {
                value = scrollFinal;
                final = true;
            }
            else {
                value = scrollDownIncrement;
            }
        }
        else {
            // Scroll up
            const scrollUpIncrement = this.viewportScrollOffset - this.viewportViewportSize;
            if (scrollUpIncrement <= scrollFinal) {
                value = scrollFinal;
                final = true;
            }
            else {
                value = scrollUpIncrement;
            }
        }
        return this.scrollTo(value).pipe(takeWhile(() => !final), expand(() => this.onTrackOngoingMousedown()));
    }
    getRelativePosition() {
        const clickPosition = this.currMousePosition - this.offset;
        const current = clickPosition / this.size;
        return current * (this.viewportScrollSize - this.viewportViewportSize);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: TrackAdapter, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.1", type: TrackAdapter, queries: [{ propertyName: "thumb", first: true, predicate: ThumbAdapter, descendants: true }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: TrackAdapter, decorators: [{
            type: Directive
        }], ctorParameters: () => [], propDecorators: { thumb: [{
                type: ContentChild,
                args: [ThumbAdapter]
            }] } });

class TrackXDirective extends TrackAdapter {
    constructor() {
        super(...arguments);
        this.cssLengthProperty = '--track-x-length';
        this.clientProperty = 'clientX';
    }
    get offset() {
        return this.clientRect.left;
    }
    get size() {
        return this.nativeElement.clientWidth;
    }
    get viewportScrollSize() {
        return this.cmp.viewport.contentWidth;
    }
    get viewportViewportSize() {
        return this.cmp.viewport.offsetWidth;
    }
    get viewportScrollOffset() {
        return this.cmp.viewport.scrollLeft;
    }
    scrollTo(left) {
        return fromPromise(this.cmp.scrollTo({ left }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: TrackXDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.1", type: TrackXDirective, isStandalone: true, selector: "[scrollbarTrackX]", providers: [{ provide: TrackAdapter, useExisting: TrackXDirective }], usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: TrackXDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[scrollbarTrackX]',
                    providers: [{ provide: TrackAdapter, useExisting: TrackXDirective }]
                }]
        }] });
class TrackYDirective extends TrackAdapter {
    constructor() {
        super(...arguments);
        this.cssLengthProperty = '--track-y-length';
        this.clientProperty = 'clientY';
    }
    get offset() {
        return this.clientRect.top;
    }
    get size() {
        return this.nativeElement.clientHeight;
    }
    get viewportScrollSize() {
        return this.cmp.viewport.contentHeight;
    }
    get viewportViewportSize() {
        return this.cmp.viewport.offsetHeight;
    }
    get viewportScrollOffset() {
        return this.cmp.viewport.scrollTop;
    }
    scrollTo(top) {
        return fromPromise(this.cmp.scrollTo({ top }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: TrackYDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.1", type: TrackYDirective, isStandalone: true, selector: "[scrollbarTrackY]", providers: [{ provide: TrackAdapter, useExisting: TrackYDirective }], usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: TrackYDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[scrollbarTrackY]',
                    providers: [{ provide: TrackAdapter, useExisting: TrackYDirective }]
                }]
        }] });

class ThumbXDirective extends ThumbAdapter {
    get clientProperty() {
        return 'clientX';
    }
    get pageProperty() {
        return 'pageX';
    }
    get viewportScrollMax() {
        return this.cmp.viewport.scrollMaxX;
    }
    get dragStartOffset() {
        return this.clientRect.left + this.document.defaultView.pageXOffset;
    }
    get offset() {
        return this.clientRect.left;
    }
    get size() {
        return this.nativeElement.clientWidth;
    }
    constructor() {
        super();
        this.axis = 'x';
        effect(() => {
            if (this.cmp.direction() === 'rtl') {
                if (this.cmp.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                    this.handleDrag = (position, scrollMax) => -(scrollMax - position);
                }
                if (this.cmp.rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                    this.handleDrag = (position, scrollMax) => position - scrollMax;
                }
            }
            else {
                this.handleDrag = (position) => position;
            }
        });
    }
    scrollTo(position) {
        this.cmp.viewport.scrollXTo(position);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ThumbXDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.1", type: ThumbXDirective, isStandalone: true, selector: "[scrollbarThumbX]", providers: [{ provide: ThumbAdapter, useExisting: ThumbXDirective }], usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ThumbXDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[scrollbarThumbX]',
                    providers: [{ provide: ThumbAdapter, useExisting: ThumbXDirective }]
                }]
        }], ctorParameters: () => [] });
class ThumbYDirective extends ThumbAdapter {
    constructor() {
        super(...arguments);
        this.axis = 'y';
        this.handleDrag = (position) => position;
    }
    get pageProperty() {
        return 'pageY';
    }
    get viewportScrollMax() {
        return this.cmp.viewport.scrollMaxY;
    }
    get clientProperty() {
        return 'clientY';
    }
    get dragStartOffset() {
        return this.clientRect.top + this.document.defaultView.pageYOffset;
    }
    get offset() {
        return this.clientRect.top;
    }
    get size() {
        return this.nativeElement.clientHeight;
    }
    scrollTo(position) {
        this.cmp.viewport.scrollYTo(position);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ThumbYDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.1", type: ThumbYDirective, isStandalone: true, selector: "[scrollbarThumbY]", providers: [{ provide: ThumbAdapter, useExisting: ThumbYDirective }], usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ThumbYDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[scrollbarThumbY]',
                    providers: [{ provide: ThumbAdapter, useExisting: ThumbYDirective }]
                }]
        }] });

// @dynamic
class ScrollbarAdapter {
    constructor() {
        // Zone reference
        this.zone = inject(NgZone);
        // Host component reference
        this.cmp = inject(NG_SCROLLBAR);
        effect((onCleanup) => {
            if (this.cmp.interactionDisabled()) {
                this.pointerEventsSub?.unsubscribe();
            }
            else {
                this.zone.runOutsideAngular(() => {
                    this.pointerEventsSub = merge(
                    // Activate scrollbar thumb drag event
                    this.thumb.dragged, 
                    // Activate scrollbar track click event
                    this.track.dragged).subscribe();
                });
            }
            onCleanup(() => this.pointerEventsSub?.unsubscribe());
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollbarAdapter, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.1", type: ScrollbarAdapter, viewQueries: [{ propertyName: "sticky", first: true, predicate: ["sticky"], descendants: true, static: true }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollbarAdapter, decorators: [{
            type: Directive
        }], ctorParameters: () => [], propDecorators: { sticky: [{
                type: ViewChild,
                args: ['sticky', { static: true }]
            }] } });

class ScrollbarY extends ScrollbarAdapter {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollbarY, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.1", type: ScrollbarY, isStandalone: true, selector: "scrollbar-y", viewQueries: [{ propertyName: "track", first: true, predicate: TrackYDirective, descendants: true, static: true }, { propertyName: "thumb", first: true, predicate: ThumbYDirective, descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
    <div #sticky class="ng-scrollbar-sticky">
      <div scrollbarTrackY class="ng-scrollbar-track {{ cmp.trackClass }}">
        <div scrollbarThumbY class="ng-scrollbar-thumb {{ cmp.thumbClass }}"></div>
      </div>
    </div>
  `, isInline: true, styles: [":host{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:1}.ng-scrollbar-track{top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);pointer-events:var(--_scrollbar-pointer-events);opacity:var(--_scrollbar-opacity);background-color:var(--scrollbar-track-color);transition:var(--_scrollbar-transition);border-radius:var(--scrollbar-border-radius);position:absolute;cursor:default;z-index:1}.ng-scrollbar-thumb{box-sizing:border-box;position:absolute;transition:var(--scrollbar-thumb-transition);border-radius:var(--scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}\n", ":host{--_scrollbar-wrapper-top: 0;--_scrollbar-wrapper-left: var(--_scrollbar-wrapper-y-left);--_scrollbar-wrapper-right: var(--_scrollbar-wrapper-y-right);--_scrollbar-wrapper-height: var(--viewport-height);--_scrollbar-wrapper-width: var(--_scrollbar-thickness);--_scrollbar-track-top: var(--_vertical-top);--_scrollbar-track-bottom: var(--_vertical-bottom);--_scrollbar-track-right: var(--_vertical-right);--_scrollbar-track-left: var(--_vertical-left);--_thumb-height: calc(var(--thumb-y-length) * 1px);--_thumb-width: 100%;--_scrollbar-thumb-transform-from: 0 0;--_scrollbar-thumb-transform-to: 0 calc(var(--_scrollbar-y-thumb-transform-to-value) * 1px)}.ng-scrollbar-track{width:var(--_track-y-thickness)}.ng-scrollbar-track:hover{--_track-y-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-y-color: var(--scrollbar-thumb-hover-color)}.ng-scrollbar-thumb{animation-timeline:var(--_animation-timeline-y);min-height:calc(var(--scrollbar-thumb-min-size) * 1px);display:var(--_vertical-thumb-display);background-color:var(--_thumb-y-color)}\n"], dependencies: [{ kind: "directive", type: TrackYDirective, selector: "[scrollbarTrackY]" }, { kind: "directive", type: ThumbYDirective, selector: "[scrollbarThumbY]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollbarY, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'scrollbar-y', template: `
    <div #sticky class="ng-scrollbar-sticky">
      <div scrollbarTrackY class="ng-scrollbar-track {{ cmp.trackClass }}">
        <div scrollbarThumbY class="ng-scrollbar-thumb {{ cmp.thumbClass }}"></div>
      </div>
    </div>
  `, imports: [TrackYDirective, ThumbYDirective], changeDetection: ChangeDetectionStrategy.OnPush, styles: [":host{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:1}.ng-scrollbar-track{top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);pointer-events:var(--_scrollbar-pointer-events);opacity:var(--_scrollbar-opacity);background-color:var(--scrollbar-track-color);transition:var(--_scrollbar-transition);border-radius:var(--scrollbar-border-radius);position:absolute;cursor:default;z-index:1}.ng-scrollbar-thumb{box-sizing:border-box;position:absolute;transition:var(--scrollbar-thumb-transition);border-radius:var(--scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}\n", ":host{--_scrollbar-wrapper-top: 0;--_scrollbar-wrapper-left: var(--_scrollbar-wrapper-y-left);--_scrollbar-wrapper-right: var(--_scrollbar-wrapper-y-right);--_scrollbar-wrapper-height: var(--viewport-height);--_scrollbar-wrapper-width: var(--_scrollbar-thickness);--_scrollbar-track-top: var(--_vertical-top);--_scrollbar-track-bottom: var(--_vertical-bottom);--_scrollbar-track-right: var(--_vertical-right);--_scrollbar-track-left: var(--_vertical-left);--_thumb-height: calc(var(--thumb-y-length) * 1px);--_thumb-width: 100%;--_scrollbar-thumb-transform-from: 0 0;--_scrollbar-thumb-transform-to: 0 calc(var(--_scrollbar-y-thumb-transform-to-value) * 1px)}.ng-scrollbar-track{width:var(--_track-y-thickness)}.ng-scrollbar-track:hover{--_track-y-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-y-color: var(--scrollbar-thumb-hover-color)}.ng-scrollbar-thumb{animation-timeline:var(--_animation-timeline-y);min-height:calc(var(--scrollbar-thumb-min-size) * 1px);display:var(--_vertical-thumb-display);background-color:var(--_thumb-y-color)}\n"] }]
        }], propDecorators: { track: [{
                type: ViewChild,
                args: [TrackYDirective, { static: true }]
            }], thumb: [{
                type: ViewChild,
                args: [ThumbYDirective, { static: true }]
            }] } });
class ScrollbarX extends ScrollbarAdapter {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollbarX, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.1", type: ScrollbarX, isStandalone: true, selector: "scrollbar-x", viewQueries: [{ propertyName: "track", first: true, predicate: TrackXDirective, descendants: true, static: true }, { propertyName: "thumb", first: true, predicate: ThumbXDirective, descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
    <div #sticky class="ng-scrollbar-sticky">
      <div scrollbarTrackX class="ng-scrollbar-track {{ cmp.trackClass }}">
        <div scrollbarThumbX class="ng-scrollbar-thumb {{ cmp.thumbClass }}"
             [attr.dir]="cmp.direction()"></div>
      </div>
    </div>
  `, isInline: true, styles: [":host{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:1}.ng-scrollbar-track{top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);pointer-events:var(--_scrollbar-pointer-events);opacity:var(--_scrollbar-opacity);background-color:var(--scrollbar-track-color);transition:var(--_scrollbar-transition);border-radius:var(--scrollbar-border-radius);position:absolute;cursor:default;z-index:1}.ng-scrollbar-thumb{box-sizing:border-box;position:absolute;transition:var(--scrollbar-thumb-transition);border-radius:var(--scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}\n", ":host{--_scrollbar-wrapper-top: var(--_scrollbar-wrapper-x-top);--_scrollbar-wrapper-left: 0;--_scrollbar-wrapper-right: 0;--_scrollbar-wrapper-height: var(--_scrollbar-thickness);--_scrollbar-wrapper-width: var(--viewport-width);--_scrollbar-track-top: var(--_horizontal-top);--_scrollbar-track-bottom: var(--_horizontal-bottom);--_scrollbar-track-right: var(--_horizontal-right);--_scrollbar-track-left: var(--_horizontal-left);--_thumb-height: 100%;--_thumb-width: calc(var(--thumb-x-length) * 1px);--_scrollbar-thumb-transform-from: 0;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * 1px)}.ng-scrollbar-track{height:var(--_track-x-thickness)}.ng-scrollbar-track:hover{--_track-x-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-x-color: var(--scrollbar-thumb-hover-color)}.ng-scrollbar-thumb{animation-timeline:var(--_animation-timeline-x);min-width:calc(var(--scrollbar-thumb-min-size) * 1px);display:var(--_horizontal-thumb-display);background-color:var(--_thumb-x-color)}.ng-scrollbar-thumb[dir=rtl]{animation-name:scrollbarThumbRTLAnimation;will-change:right;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * -1px)}@keyframes scrollbarThumbRTLAnimation{0%{right:var(--_scrollbar-thumb-transform-from)}to{right:calc(var(--_scrollbar-thumb-transform-to) * -1)}}\n"], dependencies: [{ kind: "directive", type: TrackXDirective, selector: "[scrollbarTrackX]" }, { kind: "directive", type: ThumbXDirective, selector: "[scrollbarThumbX]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: ScrollbarX, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'scrollbar-x', template: `
    <div #sticky class="ng-scrollbar-sticky">
      <div scrollbarTrackX class="ng-scrollbar-track {{ cmp.trackClass }}">
        <div scrollbarThumbX class="ng-scrollbar-thumb {{ cmp.thumbClass }}"
             [attr.dir]="cmp.direction()"></div>
      </div>
    </div>
  `, imports: [TrackXDirective, ThumbXDirective], changeDetection: ChangeDetectionStrategy.OnPush, styles: [":host{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:1}.ng-scrollbar-track{top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);pointer-events:var(--_scrollbar-pointer-events);opacity:var(--_scrollbar-opacity);background-color:var(--scrollbar-track-color);transition:var(--_scrollbar-transition);border-radius:var(--scrollbar-border-radius);position:absolute;cursor:default;z-index:1}.ng-scrollbar-thumb{box-sizing:border-box;position:absolute;transition:var(--scrollbar-thumb-transition);border-radius:var(--scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}\n", ":host{--_scrollbar-wrapper-top: var(--_scrollbar-wrapper-x-top);--_scrollbar-wrapper-left: 0;--_scrollbar-wrapper-right: 0;--_scrollbar-wrapper-height: var(--_scrollbar-thickness);--_scrollbar-wrapper-width: var(--viewport-width);--_scrollbar-track-top: var(--_horizontal-top);--_scrollbar-track-bottom: var(--_horizontal-bottom);--_scrollbar-track-right: var(--_horizontal-right);--_scrollbar-track-left: var(--_horizontal-left);--_thumb-height: 100%;--_thumb-width: calc(var(--thumb-x-length) * 1px);--_scrollbar-thumb-transform-from: 0;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * 1px)}.ng-scrollbar-track{height:var(--_track-x-thickness)}.ng-scrollbar-track:hover{--_track-x-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-x-color: var(--scrollbar-thumb-hover-color)}.ng-scrollbar-thumb{animation-timeline:var(--_animation-timeline-x);min-width:calc(var(--scrollbar-thumb-min-size) * 1px);display:var(--_horizontal-thumb-display);background-color:var(--_thumb-x-color)}.ng-scrollbar-thumb[dir=rtl]{animation-name:scrollbarThumbRTLAnimation;will-change:right;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * -1px)}@keyframes scrollbarThumbRTLAnimation{0%{right:var(--_scrollbar-thumb-transform-from)}to{right:calc(var(--_scrollbar-thumb-transform-to) * -1)}}\n"] }]
        }], propDecorators: { track: [{
                type: ViewChild,
                args: [TrackXDirective, { static: true }]
            }], thumb: [{
                type: ViewChild,
                args: [ThumbXDirective, { static: true }]
            }] } });

class Scrollbars {
    constructor() {
        this.cmp = inject(NG_SCROLLBAR);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: Scrollbars, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.2.1", type: Scrollbars, isStandalone: true, selector: "scrollbars", viewQueries: [{ propertyName: "y", first: true, predicate: ScrollbarY, descendants: true }, { propertyName: "x", first: true, predicate: ScrollbarX, descendants: true }], ngImport: i0, template: `
    @if (cmp.verticalUsed()) {
      <scrollbar-y/>
    }
    @if (cmp.horizontalUsed()) {
      <scrollbar-x/>
    }
  `, isInline: true, styles: [":host{display:contents}\n"], dependencies: [{ kind: "component", type: ScrollbarX, selector: "scrollbar-x" }, { kind: "component", type: ScrollbarY, selector: "scrollbar-y" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: Scrollbars, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'scrollbars', changeDetection: ChangeDetectionStrategy.OnPush, imports: [ScrollbarX, ScrollbarY], template: `
    @if (cmp.verticalUsed()) {
      <scrollbar-y/>
    }
    @if (cmp.horizontalUsed()) {
      <scrollbar-x/>
    }
  `, styles: [":host{display:contents}\n"] }]
        }], propDecorators: { y: [{
                type: ViewChild,
                args: [ScrollbarY]
            }], x: [{
                type: ViewChild,
                args: [ScrollbarX]
            }] } });

class NgScrollbar extends NgScrollbarCore {
    constructor() {
        super(...arguments);
        this.viewport = new ViewportAdapter(this.nativeElement);
    }
    ngOnInit() {
        this.viewport.init(this.contentWrapper.nativeElement);
        super.ngOnInit();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbar, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.1", type: NgScrollbar, isStandalone: true, selector: "ng-scrollbar:not([externalViewport])", providers: [
            { provide: NG_SCROLLBAR, useExisting: NgScrollbar }
        ], viewQueries: [{ propertyName: "contentWrapper", first: true, predicate: ["contentWrapper"], descendants: true, static: true }, { propertyName: "scrollbars", first: true, predicate: Scrollbars, descendants: true, static: true }], exportAs: ["ngScrollbar"], usesInheritance: true, hostDirectives: [{ directive: ScrollViewport }], ngImport: i0, template: `
    <div #contentWrapper>
      <ng-content/>
      <scrollbars/>
    </div>
  `, isInline: true, styles: [":host{display:block;position:relative;overflow:hidden;max-height:100%;max-width:100%;--scrollbar-border-radius: 7px;--scrollbar-thickness: 5;--scrollbar-offset: 4;--scrollbar-track-color: transparent;--scrollbar-track-transition: height ease-out .15s, width ease-out .15s;--scrollbar-thumb-color: rgba(0, 0, 0, .2);--scrollbar-thumb-hover-color: var(--scrollbar-thumb-color);--scrollbar-hover-thickness: var(--scrollbar-thickness);--scrollbar-thumb-transition: none;--scrollbar-thumb-min-size: 20;--scrollbar-hover-transition-duration: .4s;--scrollbar-hover-transition-delay: .8s;--scrollbar-overscroll-behavior: initial;--scrollbar-mobile-overscroll-behavior: none;--_scrollbar-transition: var(--scrollbar-track-transition);--_scrollbar-opacity: initial;--_scrollbar-thickness: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_thumb-x-color: var(--scrollbar-thumb-color);--_thumb-y-color: var(--scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}:host{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior)}:host ::ng-deep .ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{scrollbar-width:none}:host.ng-scroll-viewport::-webkit-scrollbar,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport::-webkit-scrollbar{display:none}:host[position=invertX],:host[position=invertAll]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}:host[dir=ltr]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=ltr][position=invertY],:host[dir=ltr][position=invertAll]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}:host[dir=rtl]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=rtl][position=invertY],:host[dir=rtl][position=invertAll]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}:host[verticalUsed=true][horizontalUsed=true]{--_scrollbar-thickness-margin: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}:host[horizontalUsed=true]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}:host[horizontalUsed=true][position=invertX],:host[horizontalUsed=true][position=invertAll]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}:host[verticalUsed=true][dir=ltr]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[verticalUsed=true][dir=rtl]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=ltr],:host[verticalUsed=true][position=invertAll][dir=ltr]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=rtl],:host[verticalUsed=true][position=invertAll][dir=rtl]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[appearance=standard][verticalUsed=true][dir=ltr]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][verticalUsed=true][dir=rtl]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=standard][verticalUsed=true][position=invertY][dir=ltr],:host[appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=standard][verticalUsed=true][position=invertY][dir=rtl],:host[appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][horizontalUsed=true]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][horizontalUsed=true][position=invertX],:host[appearance=standard][horizontalUsed=true][position=invertAll]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}:host[visibility=hover]{--_scrollbar-opacity: 0;--_scrollbar-transition: var(--scrollbar-track-transition), opacity var(--scrollbar-hover-transition-duration) var(--scrollbar-hover-transition-delay)}:host[visibility=hover]:hover,:host[visibility=hover]:active,:host[visibility=hover]:focus{--_scrollbar-opacity: 1;--_scrollbar-transition: var(--scrollbar-track-transition), opacity var(--scrollbar-hover-transition-duration)}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=start]{left:0;right:unset}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=end]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=start]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=end]{left:0;right:unset}:host ::ng-deep .ng-scroll-reached-wrapper,:host ::ng-deep .scroll-reached-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}:host ::ng-deep .ng-scroll-reached-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}:host ::ng-deep [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end]{display:none}:host ::ng-deep [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom]{display:none}:host ::ng-deep .scroll-reached-trigger-element{background:red}:host ::ng-deep .scroll-reached-trigger-element[trigger=top],:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=start],:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}:host ::ng-deep .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}:host[verticalUsed=true]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y;--_scrollbar-y-thumb-transform-to-value: calc(var(--track-y-length) - var(--thumb-y-length))}:host[horizontalUsed=true]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x;--_scrollbar-x-thumb-transform-to-value: calc(var(--track-x-length) - var(--thumb-x-length))}:host[verticalUsed=true][horizontalUsed=true]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}:host[orientation=vertical]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}:host[orientation=horizontal]{--_viewport-overflow: auto hidden}:host[disableInteraction=true]{--_scrollbar-pointer-events: none}:host[isVerticallyScrollable=false]{--_vertical-thumb-display: none}:host[isHorizontallyScrollable=false]{--_horizontal-thumb-display: none}:host[dragging=x],:host[dragging=y]{--_viewport-user-select: none}:host[horizontalUsed=true]{--thumb-x-length: max(calc(var(--viewport-width) * var(--track-x-length) / var(--content-width)), var(--scrollbar-thumb-min-size))}:host[verticalUsed=true]{--thumb-y-length: max(calc(var(--viewport-height) * var(--track-y-length) / var(--content-height)), var(--scrollbar-thumb-min-size))}:host[dragging=x]{--_track-x-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(--scrollbar-thumb-hover-color)}:host[dragging=y]{--_track-y-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(--scrollbar-thumb-hover-color)}:host[mobile=true]{--_viewport-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior)}\n"], dependencies: [{ kind: "component", type: Scrollbars, selector: "scrollbars" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbar, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'ng-scrollbar:not([externalViewport])', exportAs: 'ngScrollbar', imports: [Scrollbars], hostDirectives: [ScrollViewport], template: `
    <div #contentWrapper>
      <ng-content/>
      <scrollbars/>
    </div>
  `, changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        { provide: NG_SCROLLBAR, useExisting: NgScrollbar }
                    ], styles: [":host{display:block;position:relative;overflow:hidden;max-height:100%;max-width:100%;--scrollbar-border-radius: 7px;--scrollbar-thickness: 5;--scrollbar-offset: 4;--scrollbar-track-color: transparent;--scrollbar-track-transition: height ease-out .15s, width ease-out .15s;--scrollbar-thumb-color: rgba(0, 0, 0, .2);--scrollbar-thumb-hover-color: var(--scrollbar-thumb-color);--scrollbar-hover-thickness: var(--scrollbar-thickness);--scrollbar-thumb-transition: none;--scrollbar-thumb-min-size: 20;--scrollbar-hover-transition-duration: .4s;--scrollbar-hover-transition-delay: .8s;--scrollbar-overscroll-behavior: initial;--scrollbar-mobile-overscroll-behavior: none;--_scrollbar-transition: var(--scrollbar-track-transition);--_scrollbar-opacity: initial;--_scrollbar-thickness: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_thumb-x-color: var(--scrollbar-thumb-color);--_thumb-y-color: var(--scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}:host{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior)}:host ::ng-deep .ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{scrollbar-width:none}:host.ng-scroll-viewport::-webkit-scrollbar,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport::-webkit-scrollbar{display:none}:host[position=invertX],:host[position=invertAll]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}:host[dir=ltr]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=ltr][position=invertY],:host[dir=ltr][position=invertAll]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}:host[dir=rtl]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=rtl][position=invertY],:host[dir=rtl][position=invertAll]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}:host[verticalUsed=true][horizontalUsed=true]{--_scrollbar-thickness-margin: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}:host[horizontalUsed=true]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}:host[horizontalUsed=true][position=invertX],:host[horizontalUsed=true][position=invertAll]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}:host[verticalUsed=true][dir=ltr]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[verticalUsed=true][dir=rtl]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=ltr],:host[verticalUsed=true][position=invertAll][dir=ltr]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=rtl],:host[verticalUsed=true][position=invertAll][dir=rtl]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[appearance=standard][verticalUsed=true][dir=ltr]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][verticalUsed=true][dir=rtl]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=standard][verticalUsed=true][position=invertY][dir=ltr],:host[appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=standard][verticalUsed=true][position=invertY][dir=rtl],:host[appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][horizontalUsed=true]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][horizontalUsed=true][position=invertX],:host[appearance=standard][horizontalUsed=true][position=invertAll]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}:host[visibility=hover]{--_scrollbar-opacity: 0;--_scrollbar-transition: var(--scrollbar-track-transition), opacity var(--scrollbar-hover-transition-duration) var(--scrollbar-hover-transition-delay)}:host[visibility=hover]:hover,:host[visibility=hover]:active,:host[visibility=hover]:focus{--_scrollbar-opacity: 1;--_scrollbar-transition: var(--scrollbar-track-transition), opacity var(--scrollbar-hover-transition-duration)}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=start]{left:0;right:unset}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=end]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=start]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=end]{left:0;right:unset}:host ::ng-deep .ng-scroll-reached-wrapper,:host ::ng-deep .scroll-reached-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}:host ::ng-deep .ng-scroll-reached-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}:host ::ng-deep [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end]{display:none}:host ::ng-deep [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom]{display:none}:host ::ng-deep .scroll-reached-trigger-element{background:red}:host ::ng-deep .scroll-reached-trigger-element[trigger=top],:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=start],:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}:host ::ng-deep .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}:host[verticalUsed=true]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y;--_scrollbar-y-thumb-transform-to-value: calc(var(--track-y-length) - var(--thumb-y-length))}:host[horizontalUsed=true]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x;--_scrollbar-x-thumb-transform-to-value: calc(var(--track-x-length) - var(--thumb-x-length))}:host[verticalUsed=true][horizontalUsed=true]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}:host[orientation=vertical]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}:host[orientation=horizontal]{--_viewport-overflow: auto hidden}:host[disableInteraction=true]{--_scrollbar-pointer-events: none}:host[isVerticallyScrollable=false]{--_vertical-thumb-display: none}:host[isHorizontallyScrollable=false]{--_horizontal-thumb-display: none}:host[dragging=x],:host[dragging=y]{--_viewport-user-select: none}:host[horizontalUsed=true]{--thumb-x-length: max(calc(var(--viewport-width) * var(--track-x-length) / var(--content-width)), var(--scrollbar-thumb-min-size))}:host[verticalUsed=true]{--thumb-y-length: max(calc(var(--viewport-height) * var(--track-y-length) / var(--content-height)), var(--scrollbar-thumb-min-size))}:host[dragging=x]{--_track-x-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(--scrollbar-thumb-hover-color)}:host[dragging=y]{--_track-y-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(--scrollbar-thumb-hover-color)}:host[mobile=true]{--_viewport-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior)}\n"] }]
        }], propDecorators: { contentWrapper: [{
                type: ViewChild,
                args: ['contentWrapper', { static: true }]
            }], scrollbars: [{
                type: ViewChild,
                args: [Scrollbars, { static: true }]
            }] } });

class NgScrollbarExt extends NgScrollbarCore {
    constructor() {
        super(...arguments);
        this.appRef = inject(ApplicationRef);
        this.cfr = inject(ComponentFactoryResolver);
    }
    get viewport() {
        return this.viewportAdapter;
    }
    get scrollbars() {
        return this.scrollbarWrapperRef?.instance;
    }
    ngOnInit() {
        if (this.customViewport) {
            this.viewportAdapter = this.customViewport.viewport;
        }
        else {
            let viewportElement;
            // If viewport selector was defined, query the element
            if (this.externalViewport) {
                viewportElement = this.nativeElement.querySelector(this.externalViewport);
            }
            if (viewportElement) {
                this.viewportAdapter = new ViewportAdapter(viewportElement);
            }
            else {
                console.error(`[NgScrollbar]: Could not find the viewport element for the provided selector "${this.externalViewport}"`);
            }
        }
        let spacerElement;
        if (this.externalSpacer) {
            spacerElement = this.nativeElement.querySelector(this.externalSpacer);
            if (!spacerElement) {
                console.error(`[NgScrollbar]: Could not find the spacer element for the provided selector "${this.externalSpacer}"`);
            }
        }
        let contentWrapperElement;
        if (this.externalContentWrapper) {
            contentWrapperElement = this.nativeElement.querySelector(this.externalContentWrapper);
            if (!contentWrapperElement) {
                console.error(`[NgScrollbar]: Could not find the content wrapper element for the provided selector "${this.externalContentWrapper}"`);
            }
        }
        this.viewport.init(contentWrapperElement, spacerElement);
        // Create/destroy ScrollbarWrapper component when disabled state changes
        if (!this.scrollbarWrapperRef) {
            const injector = Injector.create({ providers: [{ provide: NG_SCROLLBAR, useValue: this }] });
            this.scrollbarWrapperRef = this.cfr.resolveComponentFactory(Scrollbars).create(injector);
            // Attach the host view of the component to the main change detection tree, so that its lifecycle hooks will run.
            this.appRef.attachView(this.scrollbarWrapperRef.hostView);
            // Move the created component inside the content wrapper
            this.viewport.contentWrapperElement.appendChild(this.scrollbarWrapperRef.location.nativeElement);
        }
        super.ngOnInit();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarExt, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.1", type: NgScrollbarExt, isStandalone: true, selector: "ng-scrollbar[externalViewport]", inputs: { externalViewport: "externalViewport", externalContentWrapper: "externalContentWrapper", externalSpacer: "externalSpacer" }, host: { properties: { "class.ng-scrollbar-external-viewport": "true" } }, providers: [
            { provide: NG_SCROLLBAR, useExisting: NgScrollbarExt },
            { provide: NgScrollbarCore, useExisting: NgScrollbar }
        ], queries: [{ propertyName: "customViewport", first: true, predicate: ScrollViewport, descendants: true, static: true }], exportAs: ["ngScrollbar"], usesInheritance: true, ngImport: i0, template: '<ng-content/>', isInline: true, styles: [":host{display:block;position:relative;overflow:hidden;max-height:100%;max-width:100%;--scrollbar-border-radius: 7px;--scrollbar-thickness: 5;--scrollbar-offset: 4;--scrollbar-track-color: transparent;--scrollbar-track-transition: height ease-out .15s, width ease-out .15s;--scrollbar-thumb-color: rgba(0, 0, 0, .2);--scrollbar-thumb-hover-color: var(--scrollbar-thumb-color);--scrollbar-hover-thickness: var(--scrollbar-thickness);--scrollbar-thumb-transition: none;--scrollbar-thumb-min-size: 20;--scrollbar-hover-transition-duration: .4s;--scrollbar-hover-transition-delay: .8s;--scrollbar-overscroll-behavior: initial;--scrollbar-mobile-overscroll-behavior: none;--_scrollbar-transition: var(--scrollbar-track-transition);--_scrollbar-opacity: initial;--_scrollbar-thickness: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_thumb-x-color: var(--scrollbar-thumb-color);--_thumb-y-color: var(--scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}:host{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior)}:host ::ng-deep .ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{scrollbar-width:none}:host.ng-scroll-viewport::-webkit-scrollbar,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport::-webkit-scrollbar{display:none}:host[position=invertX],:host[position=invertAll]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}:host[dir=ltr]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=ltr][position=invertY],:host[dir=ltr][position=invertAll]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}:host[dir=rtl]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=rtl][position=invertY],:host[dir=rtl][position=invertAll]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}:host[verticalUsed=true][horizontalUsed=true]{--_scrollbar-thickness-margin: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}:host[horizontalUsed=true]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}:host[horizontalUsed=true][position=invertX],:host[horizontalUsed=true][position=invertAll]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}:host[verticalUsed=true][dir=ltr]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[verticalUsed=true][dir=rtl]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=ltr],:host[verticalUsed=true][position=invertAll][dir=ltr]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=rtl],:host[verticalUsed=true][position=invertAll][dir=rtl]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[appearance=standard][verticalUsed=true][dir=ltr]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][verticalUsed=true][dir=rtl]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=standard][verticalUsed=true][position=invertY][dir=ltr],:host[appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=standard][verticalUsed=true][position=invertY][dir=rtl],:host[appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][horizontalUsed=true]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][horizontalUsed=true][position=invertX],:host[appearance=standard][horizontalUsed=true][position=invertAll]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}:host[visibility=hover]{--_scrollbar-opacity: 0;--_scrollbar-transition: var(--scrollbar-track-transition), opacity var(--scrollbar-hover-transition-duration) var(--scrollbar-hover-transition-delay)}:host[visibility=hover]:hover,:host[visibility=hover]:active,:host[visibility=hover]:focus{--_scrollbar-opacity: 1;--_scrollbar-transition: var(--scrollbar-track-transition), opacity var(--scrollbar-hover-transition-duration)}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=start]{left:0;right:unset}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=end]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=start]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=end]{left:0;right:unset}:host ::ng-deep .ng-scroll-reached-wrapper,:host ::ng-deep .scroll-reached-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}:host ::ng-deep .ng-scroll-reached-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}:host ::ng-deep [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end]{display:none}:host ::ng-deep [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom]{display:none}:host ::ng-deep .scroll-reached-trigger-element{background:red}:host ::ng-deep .scroll-reached-trigger-element[trigger=top],:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=start],:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}:host ::ng-deep .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}:host[verticalUsed=true]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y;--_scrollbar-y-thumb-transform-to-value: calc(var(--track-y-length) - var(--thumb-y-length))}:host[horizontalUsed=true]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x;--_scrollbar-x-thumb-transform-to-value: calc(var(--track-x-length) - var(--thumb-x-length))}:host[verticalUsed=true][horizontalUsed=true]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}:host[orientation=vertical]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}:host[orientation=horizontal]{--_viewport-overflow: auto hidden}:host[disableInteraction=true]{--_scrollbar-pointer-events: none}:host[isVerticallyScrollable=false]{--_vertical-thumb-display: none}:host[isHorizontallyScrollable=false]{--_horizontal-thumb-display: none}:host[dragging=x],:host[dragging=y]{--_viewport-user-select: none}:host[horizontalUsed=true]{--thumb-x-length: max(calc(var(--viewport-width) * var(--track-x-length) / var(--content-width)), var(--scrollbar-thumb-min-size))}:host[verticalUsed=true]{--thumb-y-length: max(calc(var(--viewport-height) * var(--track-y-length) / var(--content-height)), var(--scrollbar-thumb-min-size))}:host[dragging=x]{--_track-x-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(--scrollbar-thumb-hover-color)}:host[dragging=y]{--_track-y-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(--scrollbar-thumb-hover-color)}:host[mobile=true]{--_viewport-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior)}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarExt, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'ng-scrollbar[externalViewport]', exportAs: 'ngScrollbar', template: '<ng-content/>', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[class.ng-scrollbar-external-viewport]': 'true'
                    }, providers: [
                        { provide: NG_SCROLLBAR, useExisting: NgScrollbarExt },
                        { provide: NgScrollbarCore, useExisting: NgScrollbar }
                    ], styles: [":host{display:block;position:relative;overflow:hidden;max-height:100%;max-width:100%;--scrollbar-border-radius: 7px;--scrollbar-thickness: 5;--scrollbar-offset: 4;--scrollbar-track-color: transparent;--scrollbar-track-transition: height ease-out .15s, width ease-out .15s;--scrollbar-thumb-color: rgba(0, 0, 0, .2);--scrollbar-thumb-hover-color: var(--scrollbar-thumb-color);--scrollbar-hover-thickness: var(--scrollbar-thickness);--scrollbar-thumb-transition: none;--scrollbar-thumb-min-size: 20;--scrollbar-hover-transition-duration: .4s;--scrollbar-hover-transition-delay: .8s;--scrollbar-overscroll-behavior: initial;--scrollbar-mobile-overscroll-behavior: none;--_scrollbar-transition: var(--scrollbar-track-transition);--_scrollbar-opacity: initial;--_scrollbar-thickness: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_thumb-x-color: var(--scrollbar-thumb-color);--_thumb-y-color: var(--scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}:host{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior)}:host ::ng-deep .ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}:host.ng-scroll-viewport,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport{scrollbar-width:none}:host.ng-scroll-viewport::-webkit-scrollbar,:host.ng-scrollbar-external-viewport ::ng-deep .ng-scroll-viewport::-webkit-scrollbar{display:none}:host[position=invertX],:host[position=invertAll]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}:host[dir=ltr]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=ltr][position=invertY],:host[dir=ltr][position=invertAll]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}:host[dir=rtl]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}:host[dir=rtl][position=invertY],:host[dir=rtl][position=invertAll]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}:host[verticalUsed=true][horizontalUsed=true]{--_scrollbar-thickness-margin: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}:host[horizontalUsed=true]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}:host[horizontalUsed=true][position=invertX],:host[horizontalUsed=true][position=invertAll]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}:host[verticalUsed=true][dir=ltr]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[verticalUsed=true][dir=rtl]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=ltr],:host[verticalUsed=true][position=invertAll][dir=ltr]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}:host[verticalUsed=true][position=invertY][dir=rtl],:host[verticalUsed=true][position=invertAll][dir=rtl]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}:host[appearance=standard][verticalUsed=true][dir=ltr]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][verticalUsed=true][dir=rtl]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=standard][verticalUsed=true][position=invertY][dir=ltr],:host[appearance=standard][verticalUsed=true][position=invertAll][dir=ltr]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}:host[appearance=standard][verticalUsed=true][position=invertY][dir=rtl],:host[appearance=standard][verticalUsed=true][position=invertAll][dir=rtl]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][horizontalUsed=true]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}:host[appearance=standard][horizontalUsed=true][position=invertX],:host[appearance=standard][horizontalUsed=true][position=invertAll]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}:host[visibility=hover]{--_scrollbar-opacity: 0;--_scrollbar-transition: var(--scrollbar-track-transition), opacity var(--scrollbar-hover-transition-duration) var(--scrollbar-hover-transition-delay)}:host[visibility=hover]:hover,:host[visibility=hover]:active,:host[visibility=hover]:focus{--_scrollbar-opacity: 1;--_scrollbar-transition: var(--scrollbar-track-transition), opacity var(--scrollbar-hover-transition-duration)}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=start]{left:0;right:unset}:host[dir=ltr] ::ng-deep .scroll-reached-trigger-element[trigger=end]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=start]{right:0;left:unset}:host[dir=rtl] ::ng-deep .scroll-reached-trigger-element[trigger=end]{left:0;right:unset}:host ::ng-deep .ng-scroll-reached-wrapper,:host ::ng-deep .scroll-reached-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}:host ::ng-deep .ng-scroll-reached-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}:host ::ng-deep [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end]{display:none}:host ::ng-deep [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom]{display:none}:host ::ng-deep .scroll-reached-trigger-element{background:red}:host ::ng-deep .scroll-reached-trigger-element[trigger=top],:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=start],:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}:host ::ng-deep .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}:host ::ng-deep .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}:host ::ng-deep .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}:host ::ng-deep .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}:host[verticalUsed=true]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y;--_scrollbar-y-thumb-transform-to-value: calc(var(--track-y-length) - var(--thumb-y-length))}:host[horizontalUsed=true]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x;--_scrollbar-x-thumb-transform-to-value: calc(var(--track-x-length) - var(--thumb-x-length))}:host[verticalUsed=true][horizontalUsed=true]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}:host[orientation=vertical]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}:host[orientation=horizontal]{--_viewport-overflow: auto hidden}:host[disableInteraction=true]{--_scrollbar-pointer-events: none}:host[isVerticallyScrollable=false]{--_vertical-thumb-display: none}:host[isHorizontallyScrollable=false]{--_horizontal-thumb-display: none}:host[dragging=x],:host[dragging=y]{--_viewport-user-select: none}:host[horizontalUsed=true]{--thumb-x-length: max(calc(var(--viewport-width) * var(--track-x-length) / var(--content-width)), var(--scrollbar-thumb-min-size))}:host[verticalUsed=true]{--thumb-y-length: max(calc(var(--viewport-height) * var(--track-y-length) / var(--content-height)), var(--scrollbar-thumb-min-size))}:host[dragging=x]{--_track-x-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(--scrollbar-thumb-hover-color)}:host[dragging=y]{--_track-y-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(--scrollbar-thumb-hover-color)}:host[mobile=true]{--_viewport-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior)}\n"] }]
        }], propDecorators: { externalViewport: [{
                type: Input
            }], externalContentWrapper: [{
                type: Input
            }], externalSpacer: [{
                type: Input
            }], customViewport: [{
                type: ContentChild,
                args: [ScrollViewport, { static: true }]
            }] } });

class NgScrollbarModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarModule, imports: [NgScrollbar,
            ScrollViewport,
            NgScrollbarExt], exports: [NgScrollbar,
            ScrollViewport,
            NgScrollbarExt] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NgScrollbarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        NgScrollbar,
                        ScrollViewport,
                        NgScrollbarExt
                    ],
                    exports: [
                        NgScrollbar,
                        ScrollViewport,
                        NgScrollbarExt
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NG_SCROLLBAR, NG_SCROLLBAR_OPTIONS, NgScrollbar, NgScrollbarExt, NgScrollbarModule, ScrollViewport, ScrollbarUpdateReason, ViewportClasses };
//# sourceMappingURL=ngx-scrollbar.mjs.map
